## Core Design Patterns in JavaScript

JavaScript's flexibility allows developers to leverage various design patterns to write modular, reusable, and maintainable code. Understanding these patterns is key to building robust applications. Here are some of the most common and useful ones:

### Creational Patterns (Concerned with object creation mechanisms)

**1. Singleton Pattern**

- **Concept:** Ensures that a class has only one instance and provides a single, global point of access to it[cite: 2]. This is useful when exactly one object is needed to coordinate actions across the system.
- **Details:** The constructor is typically controlled (made private conceptually or by convention in JS) to prevent direct instantiation outside the class logic, forcing use of a static `getInstance` method[cite: 3].
- **Real-world Use Case:** Managing shared resources like a logging service[cite: 3], a database connection pool, or application-wide configuration settings where multiple instances would cause conflicts or inconsistencies.
- **Example:**

  ```javascript
  class Logger {
    static _instance = null;
    // Add private data storage if needed
    // constructor() {} // Keep constructor simple or add initialization

    static getInstance() {
      if (Logger._instance === null) {
        Logger._instance = new Logger();
      }
      return Logger._instance;
    }

    log(message) {
      // Implementation for logging the message
      console.log(`LOG: ${message}`);
    }
  }

  const logger1 = Logger.getInstance();
  const logger2 = Logger.getInstance();

  console.log(logger1 === logger2); // true [cite: 5]
  logger1.log("Singleton test message.");
  ```

**2. Factory Pattern**

- **Concept:** Provides an interface for creating objects but lets subclasses (or the factory method itself) decide which class to instantiate[cite: 5]. It decouples the client code from the specific classes it needs to create.
- **Details:** Simplifies object creation, especially when the exact type needed depends on runtime conditions or configuration. Variations include Simple Factory, Factory Method, and Abstract Factory.
- **Real-world Use Case:** Creating different types of UI elements (e.g., buttons, inputs) based on configuration, instantiating user objects based on roles (`AdminUser`, `GuestUser`), or selecting parsers based on file formats (`JSONParser`, `XMLParser`).
- **Example (Simple Factory):**

  ```javascript
  // Base class (optional, but good practice)
  class Animal {
    constructor(name) {
      this.name = name;
    }
    speak() {
      throw new Error("Subclass must implement speak method.");
    }
  }

  class Dog extends Animal {
    speak() {
      console.log(`${this.name} says Woof!`);
    }
  }
  class Cat extends Animal {
    speak() {
      console.log(`${this.name} says Meow!`);
    }
  }

  // The Factory function
  function createAnimal(type, name) {
    switch (type.toLowerCase()) {
      case "dog":
        return new Dog(name); // [cite: 7]
      case "cat":
        return new Cat(name); // [cite: 7]
      default:
        throw new Error("Invalid animal type specified"); // [cite: 8]
    }
  }

  const dog = createAnimal("dog", "Buddy");
  const cat = createAnimal("cat", "Whiskers");
  dog.speak(); // Output: Buddy says Woof!
  cat.speak(); // Output: Whiskers says Meow!
  ```

### Structural Patterns (Concerned with object composition and relationships)

**3. Adapter Pattern**

- **Concept:** Allows objects with incompatible interfaces to work together[cite: 38]. It acts as a bridge, converting the interface of one object into an interface expected by the client.
- **Details:** Useful for integrating third-party libraries, legacy code, or different subsystems that weren't designed to work together directly.
- **Real-world Use Case:** Making a new logging library conform to an older `logMessage(str)` interface used throughout your app, adapting a third-party API response structure to match your application's data model, or making different database drivers usable through a single data access layer interface.
- **Example:**

  ```javascript
  // Existing interface expected by client
  class OldLogger {
    logMessage(text) {
      console.log(`OLD LOG: ${text}`);
    }
  }

  // New library with a different interface
  class NewLogger {
    writeLog(level, message) {
      console.log(`NEW LOG [${level}]: ${message}`);
    }
  }

  // Adapter
  class LoggerAdapter extends OldLogger {
    constructor(newLoggerInstance) {
      super();
      this.newLogger = newLoggerInstance;
    }

    logMessage(text) {
      // Adapt the old call to the new interface
      this.newLogger.writeLog("INFO", text);
    }
  }

  // Client code expects OldLogger interface
  function clientCode(loggerInstance) {
    loggerInstance.logMessage("This message should be logged.");
  }

  const newLogger = new NewLogger();
  const adaptedLogger = new LoggerAdapter(newLogger);

  clientCode(adaptedLogger); // Output: NEW LOG [INFO]: This message should be logged.
  ```

  _(Note: The Duck/Turkey example [cite: 39, 40] is also a classic illustration)._

**4. Decorator Pattern**

- **Concept:** Attaches additional responsibilities or behaviors to an object dynamically[cite: 15]. Decorators provide a flexible alternative to subclassing for extending functionality.
- **Details:** Wraps an object within another object (the decorator) that has the same interface but adds functionality before or after delegating to the wrapped object. Multiple decorators can be stacked.
- **Real-world Use Case:** Adding logging, timing, or access control to function calls or methods without modifying the original code; dynamically adding features like caching to data requests; enhancing UI components with borders, scrollbars, or special effects.
- **Example (Function Decorator):**

  ```javascript
  // Original function
  function fetchData(url) {
    console.log(`Workspaceing data from ${url}...`);
    // Imagine network request here
    return { data: "Sample data" };
  }

  // Decorator function to add logging
  function withLogging(fn) {
    return function (...args) {
      console.log(`Calling function: ${fn.name} with arguments:`, args);
      const start = Date.now();
      const result = fn.apply(this, args);
      const duration = Date.now() - start;
      console.log(
        `Function ${fn.name} finished in ${duration}ms. Result:`,
        result,
      );
      return result;
    };
  }

  // Decorate the original function
  const fetchDataWithLogging = withLogging(fetchData);

  fetchDataWithLogging("api/users");
  /* Output:
     Calling function: fetchData with arguments: [ 'api/users' ]
     Fetching data from api/users...
     Function fetchData finished in Xms. Result: { data: 'Sample data' }
  */
  ```

  _(Note: The Coffee example [cite: 16, 17] illustrates adding state, while function decorators are more common for adding behavior)._

**5. Proxy Pattern**

- **Concept:** Provides a surrogate or placeholder for another object to control access to it[cite: 18, 62].
- **Details:** The proxy object intercepts requests intended for the real object (the "subject"). It can perform actions like access control, caching, lazy loading, or logging before or instead of forwarding the request to the subject. JavaScript's native `Proxy` object is powerful for this.
- **Real-world Use Case:** Implementing access control (checking permissions before calling a method), caching results of expensive operations (cache proxy), lazy initialization of objects (virtual proxy), or logging interactions with an object.
- **Example (Using native JS Proxy for Access Control):**

  ```javascript
  const sensitiveData = {
    password: "123",
    userData: { name: "Admin", level: "high" },
  };

  const dataProxy = new Proxy(sensitiveData, {
    get(target, prop) {
      if (prop === "password") {
        console.error("Access denied: Cannot read password directly.");
        return undefined; // Or throw an error
      }
      return Reflect.get(target, prop); // Allow access to other properties
    },
    set(target, prop, value) {
      if (prop === "userData" && value.level !== "high") {
        console.warn("Warning: Attempting to lower admin level.");
      }
      return Reflect.set(target, prop, value); // Allow setting
    },
  });

  console.log(dataProxy.userData.name); // Output: Admin
  console.log(dataProxy.password); // Output: Access denied... undefined
  dataProxy.userData = { name: "Admin", level: "medium" }; // Output: Warning...
  ```

  _(Note: The provided LoggerProxy exampledemonstrates interception but less control than a typical proxy)._

**6. Facade Pattern**

- **Concept:** Provides a simplified, unified interface to a more complex subsystem[cite: 53]. It hides the system's complexities and makes it easier to use.
- **Details:** Instead of interacting with multiple classes or functions within a subsystem, the client interacts only with the Facade object. The Facade delegates calls to the appropriate parts of the subsystem.
- **Real-world Use Case:** Creating a simple API for a complex library (e.g., a `startVideoConference()` method that handles camera setup, microphone access, network connection, and UI rendering behind the scenes); simplifying interaction with browser APIs (like abstracting DOM manipulation or `Workspace` calls); providing a single entry point for a set of related services.
- **Example:**

  ```javascript
  // Complex subsystem parts
  class AudioSetup {
    configureMic() {
      console.log("Mic configured.");
    }
  }
  class VideoSetup {
    configureCamera() {
      console.log("Camera configured.");
    }
  }
  class NetworkConnection {
    connect() {
      console.log("Network connected.");
    }
  }
  class UIManager {
    renderInterface() {
      console.log("UI rendered.");
    }
  }

  // Facade
  class ConferenceFacade {
    constructor() {
      this.audio = new AudioSetup();
      this.video = new VideoSetup();
      this.network = new NetworkConnection();
      this.ui = new UIManager();
    }

    start() {
      console.log("Starting conference...");
      this.audio.configureMic();
      this.video.configureCamera();
      this.network.connect();
      this.ui.renderInterface();
      console.log("Conference started.");
    }
  }

  // Client uses the simple facade
  const conference = new ConferenceFacade();
  conference.start();
  /* Output:
     Starting conference...
     Mic configured.
     Camera configured.
     Network connected.
     UI rendered.
     Conference started.
  */
  ```

  _(Note: The Coffee example [cite: 54, 55] is too simple to fully convey the benefit of hiding complexity)._

**7. Composite Pattern**

- **Concept:** Allows you to compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly[cite: 34].
- **Details:** Defines a common interface for both individual objects (Leaves) and composite objects (Nodes/Composites). Composite objects typically hold collections of child components (which can be Leaves or other Composites). Operations are often delegated down the tree.
- **Real-world Use Case:** Representing UI hierarchies (a window contains panels, which contain buttons and text fields); modeling organizational structures (departments contain teams, teams contain employees); file systems (directories contain files and other directories).
- **Example:**

  ```javascript
  // Component Interface (abstract class or just convention)
  class Graphic {
    draw() {
      throw new Error("Subclass must implement draw method.");
    }
    // Common methods like add/remove might go here, throwing errors in Leaf
  }

  // Leaf
  class Circle extends Graphic {
    constructor(id) {
      super();
      this.id = id;
    }
    draw() {
      console.log(`Drawing Circle: ${this.id}`);
    }
  }

  // Composite
  class CompositeGraphic extends Graphic {
    constructor(id) {
      super();
      this.id = id;
      this.children = [];
    }
    add(graphic) {
      this.children.push(graphic);
    }
    remove(graphic) {
      /* Implementation to remove */
    }
    draw() {
      console.log(`Drawing Composite: ${this.id}`);
      this.children.forEach((child) => child.draw());
    }
  }

  const circle1 = new Circle(1);
  const circle2 = new Circle(2);
  const group1 = new CompositeGraphic("Group1");
  group1.add(circle1);
  group1.add(circle2);

  const circle3 = new Circle(3);
  const mainGroup = new CompositeGraphic("Main");
  mainGroup.add(group1);
  mainGroup.add(circle3);

  mainGroup.draw();
  /* Output:
     Drawing Composite: Main
     Drawing Composite: Group1
     Drawing Circle: 1
     Drawing Circle: 2
     Drawing Circle: 3
  */
  ```

  _(Note: The provided exampleuses `components()` method, `draw()` or `render()` is more typical for illustration)._

### Behavioral Patterns (Concerned with object interaction and responsibility distribution)

**8. Observer Pattern**

- **Concept:** Defines a one-to-many dependency between objects. When one object (the Subject/Observable) changes state, all its dependents (Observers) are notified and updated automatically[cite: 9].
- **Details:** Promotes loose coupling. The Subject only knows its Observers through a common interface and doesn't need details about their concrete classes. Observers register/unregister themselves with the Subject.
- **Real-world Use Case:** Event handling in user interfaces (DOM listeners), state management libraries (React Context, Redux, Vuex), implementing notification systems, stock tickers updating subscribed charts/displays.
- **Example:** _(Corrected from original)_

  ```javascript
  class Subject {
    constructor() {
      this.observers = []; // Initialize the observers array
    }

    attach(observer) {
      if (!this.observers.includes(observer)) {
        // Avoid duplicates
        this.observers.push(observer); // [cite: 10]
      }
    }

    detach(observer) {
      const index = this.observers.indexOf(observer);
      if (index !== -1) {
        this.observers.splice(index, 1); // [cite: 11, 12, 13]
      }
    }

    notifyObservers(data) {
      // Pass relevant data with notification
      console.log("Subject: Notifying observers...");
      this.observers.forEach((observer) => observer.update(data)); // [cite: 13, 14]
    }

    // Example method that changes state and notifies
    changeState(newState) {
      console.log(`Subject: State changed to ${newState}`);
      this.notifyObservers(newState);
    }
  }

  // Interface for observers
  class Observer {
    update(data) {
      // [cite: 14]
      throw new Error("Observer subclass must implement update method.");
    }
  }

  // Concrete Observers
  class ConcreteObserverA extends Observer {
    update(data) {
      console.log(`Observer A: Received update - ${data}`);
    }
  }
  class ConcreteObserverB extends Observer {
    update(data) {
      console.log(`Observer B: Received update - ${data}`);
    }
  }

  const subject = new Subject();
  const observer1 = new ConcreteObserverA(); // [cite: 14]
  const observer2 = new ConcreteObserverB(); // [cite: 14]

  subject.attach(observer1); // [cite: 15]
  subject.attach(observer2); // [cite: 15]

  subject.changeState("New State 1");
  /* Output:
     Subject: State changed to New State 1
     Subject: Notifying observers...
     Observer A: Received update - New State 1
     Observer B: Received update - New State 1
  */

  subject.detach(observer1);
  subject.changeState("New State 2");
  /* Output:
     Subject: State changed to New State 2
     Subject: Notifying observers...
     Observer B: Received update - New State 2
  */
  ```

**9. Strategy Pattern**

- **Concept:** Defines a family of algorithms, encapsulates each one, and makes them interchangeable[cite: 22]. Strategy lets the algorithm vary independently from the clients that use it.
- **Details:** Allows selecting an algorithm or behavior at runtime. The client holds a reference to a strategy object and delegates the algorithmic task to it.
- **Real-world Use Case:** Implementing different payment processing methods (Credit Card, PayPal, Bank Transfer)[cite: 23, 24], choosing sorting algorithms based on data characteristics, applying different validation rules based on user input context, selecting different data compression or caching strategies.
- **Example:**

  ```javascript
  // Strategy Interface (abstract class or convention)
  class ShippingStrategy {
    calculate(orderWeight) {
      throw new Error("Subclass must implement calculate.");
    }
  }

  // Concrete Strategies
  class StandardShipping extends ShippingStrategy {
    calculate(orderWeight) {
      return orderWeight * 1.5;
    } // $1.5 per kg
  }
  class ExpressShipping extends ShippingStrategy {
    calculate(orderWeight) {
      return orderWeight * 3.0;
    } // $3.0 per kg
  }
  class FreeShipping extends ShippingStrategy {
    calculate(orderWeight) {
      return 0;
    } // Free
  }

  // Context (the object that uses a strategy)
  class ShoppingCart {
    constructor() {
      this.weight = 0;
      this.shippingStrategy = new StandardShipping(); // Default strategy
    }
    setWeight(weight) {
      this.weight = weight;
    }
    setShippingStrategy(strategy) {
      this.shippingStrategy = strategy;
    }
    calculateShippingCost() {
      return this.shippingStrategy.calculate(this.weight);
    }
  }

  const cart = new ShoppingCart();
  cart.setWeight(5); // 5 kg

  console.log("Standard Shipping Cost:", cart.calculateShippingCost()); // Output: 7.5

  cart.setShippingStrategy(new ExpressShipping());
  console.log("Express Shipping Cost:", cart.calculateShippingCost()); // Output: 15

  cart.setShippingStrategy(new FreeShipping());
  console.log("Free Shipping Cost:", cart.calculateShippingCost()); // Output: 0
  ```

  _(Note: The Payment Strategy example [cite: 23, 24] is also a good illustration)._

**10. Command Pattern**

- **Concept:** Encapsulates a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations[cite: 74].
- **Details:** Decouples the object that invokes an operation (Invoker) from the object that knows how to perform it (Receiver). The Command object binds together a receiver and an action.
- **Real-world Use Case:** Implementing undo/redo functionality in editors, queuing tasks (like API calls or animations), handling UI actions (button clicks map to command objects), managing transactions.
- **Example:**

  ```javascript
  // Receiver (the object that performs the actual work)
  class Light {
    turnOn() {
      console.log("Light is ON");
    }
    turnOff() {
      console.log("Light is OFF");
    }
  }

  // Command Interface (abstract class or convention)
  class Command {
    // [cite: 75]
    execute() {
      throw new Error("Subclass must implement execute.");
    }
    // Optional: undo() method
  }

  // Concrete Commands
  class TurnOnLightCommand extends Command {
    // [cite: 75]
    constructor(light) {
      super();
      this.light = light;
    }
    execute() {
      this.light.turnOn();
    }
    // undo() { this.light.turnOff(); }
  }
  class TurnOffLightCommand extends Command {
    constructor(light) {
      super();
      this.light = light;
    }
    execute() {
      this.light.turnOff();
    }
    // undo() { this.light.turnOn(); }
  }

  // Invoker (stores and executes commands)
  class RemoteControl {
    constructor() {
      this.command = null;
    }
    setCommand(command) {
      this.command = command;
    }
    pressButton() {
      if (this.command) {
        this.command.execute();
      } else {
        console.log("No command set.");
      }
    }
    // Optional: pressUndo() { if (this.command) this.command.undo(); }
  }

  // Client setup
  const livingRoomLight = new Light();
  const turnOn = new TurnOnLightCommand(livingRoomLight);
  const turnOff = new TurnOffLightCommand(livingRoomLight);

  const remote = new RemoteControl();

  remote.setCommand(turnOn);
  remote.pressButton(); // Output: Light is ON

  remote.setCommand(turnOff);
  remote.pressButton(); // Output: Light is OFF
  ```

**11. Iterator Pattern**

- **Concept:** Provides a way to access the elements of an aggregate object (collection) sequentially without exposing its underlying representation[cite: 56].
- **Details:** Decouples the traversal logic from the collection itself. Multiple iterators can traverse the same collection independently. Defines a standard interface for iteration (e.g., `hasNext()`, `next()`). JavaScript's built-in iterables (`for...of`, spread syntax, `Array.prototype.values()`, etc.) implement this pattern natively for many objects.
- **Real-world Use Case:** Iterating over custom data structures (trees, graphs, lists), providing different ways to traverse a collection (e.g., forward, backward, depth-first, breadth-first), enabling the `for...of` loop and spread syntax for custom objects.
- **Example (Custom Iterator for a simple collection):**

  ```javascript
  class NumberCollection {
    constructor() {
      this.items = [];
    }
    add(item) {
      this.items.push(item);
    }

    // Make the collection iterable using the Iterator pattern
    [Symbol.iterator]() {
      let index = 0;
      const items = this.items;
      return {
        next: () => {
          if (index < items.length) {
            return { value: items[index++], done: false };
          } else {
            return { value: undefined, done: true };
          }
        },
      };
    }
  }

  const collection = new NumberCollection();
  collection.add(10);
  collection.add(20);
  collection.add(30);

  // Use the iterator implicitly with for...of
  console.log("Using for...of:");
  for (const item of collection) {
    console.log(item);
  }
  // Output: 10, 20, 30

  // Use the iterator explicitly
  console.log("\nUsing explicit iterator:");
  const iterator = collection[Symbol.iterator]();
  console.log(iterator.next()); // { value: 10, done: false }
  console.log(iterator.next()); // { value: 20, done: false }
  console.log(iterator.next()); // { value: 30, done: false }
  console.log(iterator.next()); // { value: undefined, done: true }
  ```

  _(Note: The provided examples [cite: 57, 58, 140, 141] are too abstract; using `Symbol.iterator` is the standard JS way)._

**12. Mediator Pattern**

- **Concept:** Defines an object (the Mediator) that encapsulates how a set of objects (Colleagues) interact[cite: 59, 145]. It promotes loose coupling by keeping colleagues from referring to each other explicitly.
- **Details:** Colleagues communicate only with the Mediator, which then coordinates the interactions among them. This centralizes complex communication logic.
- **Real-world Use Case:** Chat applications (Mediator is the chat room, users are Colleagues), coordinating UI elements (e.g., enabling/disabling buttons based on input field state), complex form logic where changes in one field affect others, air traffic control systems.
- **Example:**

  ```javascript
  // Mediator Interface (optional, could be concrete class directly)
  class ChatMediator {
    sendMessage(user, message) {
      throw new Error("Subclass must implement.");
    }
    addUser(user) {
      throw new Error("Subclass must implement.");
    }
  }

  // Concrete Mediator
  class ChatRoom extends ChatMediator {
    constructor() {
      super();
      this.users = [];
    }
    addUser(user) {
      this.users.push(user);
      user.setMediator(this); // Link user back to mediator
    }
    sendMessage(sender, message) {
      console.log(`[${sender.name} -> Room]: ${message}`);
      this.users.forEach((user) => {
        if (user !== sender) {
          // Don't send back to sender
          user.receive(sender.name, message);
        }
      });
    }
  }

  // Colleague Interface (optional, convention)
  class User {
    // [cite: 60]
    constructor(name) {
      this.name = name;
      this.mediator = null;
    }
    setMediator(mediator) {
      this.mediator = mediator;
    }
    send(message) {
      // [cite: 60]
      if (this.mediator) {
        this.mediator.sendMessage(this, message);
      }
    }
    receive(from, message) {
      console.log(`[${this.name} <- ${from}]: ${message}`);
    }
  }

  // Client usage
  const chatRoom = new ChatRoom(); // [cite: 60]

  const user1 = new User("Alice"); // [cite: 61]
  const user2 = new User("Bob"); // [cite: 61]
  const user3 = new User("Charlie");

  chatRoom.addUser(user1);
  chatRoom.addUser(user2);
  chatRoom.addUser(user3);

  user1.send("Hello everyone!");
  // Output:
  // [Alice -> Room]: Hello everyone!
  // [Bob <- Alice]: Hello everyone!
  // [Charlie <- Alice]: Hello everyone!

  user2.send("Hi Alice!");
  // Output:
  // [Bob -> Room]: Hi Alice!
  // [Alice <- Bob]: Hi Alice!
  // [Charlie <- Bob]: Hi Alice!
  ```

### JavaScript Specific Patterns

**13. Module Pattern / Revealing Module Pattern**

- **Concept:** Uses closures (often via IIFEs - Immediately Invoked Function Expressions) to create private scopes, encapsulating implementation details and exposing only a public API. This was fundamental for organizing code and avoiding global namespace pollution before ES6 modules.
- **Details:**
  - **Module Pattern:** Returns an object literal containing the public members.
  - **Revealing Module Pattern:** Defines all members privately and then returns an object literal containing only _references_ to the private members that should be public. Often considered cleaner.
- **Real-world Use Case:** Creating reusable components or libraries with private state and methods (e.g., counters, configuration managers, service objects) without polluting the global scope. Essential for understanding older JavaScript codebases and libraries.
- **Example (Revealing Module Pattern):**

  ```javascript
  const counterModule = (function () {
    let _count = 0; // Private variable

    // Private function
    function _log(message) {
      console.log(`Counter log: ${message}`);
    }

    // Public functions (defined privately)
    function increment() {
      _count++;
      _log(`Incremented to ${_count}`);
    }

    function decrement() {
      _count--;
      _log(`Decremented to ${_count}`);
    }

    function getCount() {
      return _count;
    }

    // Reveal public pointers to private functions/variables
    return {
      increment: increment,
      decrement: decrement,
      value: getCount, // Can rename public members
    };
  })(); // IIFE executes immediately

  console.log(counterModule.value()); // Output: 0
  counterModule.increment(); // Output: Counter log: Incremented to 1
  counterModule.increment(); // Output: Counter log: Incremented to 2
  console.log(counterModule.value()); // Output: 2
  // counterModule._count; // Undefined - private variable is inaccessible
  // counterModule._log("test"); // Error - private function is inaccessible
  ```

---

## Core Design Patterns in JavaScript (OOP & Functional Examples)

JavaScript's flexibility allows developers to leverage various design patterns—both object-oriented and functional—to write modular, reusable, and maintainable code.

### Creational Patterns

**1. Singleton Pattern**

- **Concept:** Ensures only one instance exists and provides global access.
- **OOP Approach:** (As previously shown, using a class with `getInstance`)
- **Functional Approach:** Achieved using closures and module patterns to create a single instance held in a private scope.

  ```javascript
  // Functional Singleton using a closure (Module Pattern)
  const createLoggerSingleton = () => {
    let instance; // Private instance store

    // Logger implementation details
    const loggerImplementation = {
      logs: [],
      log(message) {
        const timestamp = new Date().toISOString();
        this.logs.push({ message, timestamp });
        console.log(`LOG [${timestamp}]: ${message}`);
      },
      getLogs() {
        return this.logs;
      },
    };

    // The function to get the singleton instance
    return {
      getInstance: () => {
        if (!instance) {
          instance = loggerImplementation;
        }
        return instance;
      },
    };
  };

  const loggerSingleton = createLoggerSingleton();
  const loggerFunc1 = loggerSingleton.getInstance();
  const loggerFunc2 = loggerSingleton.getInstance();

  console.log(loggerFunc1 === loggerFunc2); // true
  loggerFunc1.log("Functional singleton message.");
  console.log(loggerFunc2.getLogs().length); // 1
  ```

**2. Factory Pattern**

- **Concept:** Creates objects without specifying the exact class, decoupling client from creation logic.
- **OOP Approach:** (As previously shown, using classes and a factory function/method).
- **Functional Approach:** A simple higher-order function acts as the factory, returning different functions or objects based on input.

  ```javascript
  // Functional Factory: Returns different *functions* based on type
  const createGreeter = (language) => {
    switch (language.toLowerCase()) {
      case "english":
        return (name) => `Hello, ${name}!`;
      case "spanish":
        return (name) => `Hola, ${name}!`;
      default:
        return (name) => `Hi there, ${name}!`; // Default greeter
    }
  };

  const greetInEnglish = createGreeter("english");
  const greetInSpanish = createGreeter("spanish");

  console.log(greetInEnglish("Alice")); // Output: Hello, Alice!
  console.log(greetInSpanish("Bob")); // Output: Hola, Bob!

  // Can also return objects if needed
  const createConfig = (env) => {
    const baseConfig = { port: 8080 };
    if (env === "production") {
      return { ...baseConfig, logLevel: "warn", useHttps: true };
    } else {
      return { ...baseConfig, logLevel: "debug", useHttps: false };
    }
  };
  const devConfig = createConfig("development");
  console.log(devConfig.logLevel); // Output: debug
  ```

### Structural Patterns

**3. Adapter Pattern**

- **Concept:** Allows incompatible interfaces to work together.
- **OOP Approach:** (As previously shown, using wrapper classes).
- **Functional Approach:** A simple wrapper function adapts the arguments or return value of one function to match the signature expected by the client.

  ```javascript
  // Client expects a function that takes one argument: (data)
  const clientProcessor = (processFn) => {
    const data = { value: 42, user: "guest" };
    console.log("Client processing result:", processFn(data));
  };

  // Service function has a different signature: (value, options)
  const serviceAction = (value, options) => {
    console.log(
      `Service action called with value=${value}, user=${options.user}`,
    );
    return value * (options.isAdmin ? 10 : 2);
  };

  // Functional Adapter
  const serviceAdapter = (data) => {
    // Adapt the single 'data' object to the two arguments needed by serviceAction
    const options = { user: data.user, isAdmin: data.user === "admin" };
    return serviceAction(data.value, options);
  };

  // Client uses the adapter function
  clientProcessor(serviceAdapter);
  // Output:
  // Service action called with value=42, user=guest
  // Client processing result: 84
  ```

**4. Decorator Pattern**

- **Concept:** Dynamically adds behavior to an object or function.
- **OOP Approach:** (As previously shown, using wrapper classes).
- **Functional Approach:** Higher-order functions are the natural way to implement decorators. They take a function as input, add behavior, and return a new function.

  ```javascript
  // Original function
  const add = (a, b) => a + b;

  // Decorator: Logs arguments and result
  const withLogging = (fn) => {
    return (...args) => {
      console.log(`Calling ${fn.name || "function"} with args:`, args);
      const result = fn(...args);
      console.log(`Result: ${result}`);
      return result;
    };
  };

  // Decorator: Checks if arguments are numbers
  const withTypeCheck = (fn) => {
    return (...args) => {
      if (args.some((arg) => typeof arg !== "number")) {
        throw new Error("All arguments must be numbers.");
      }
      return fn(...args);
    };
  };

  // Apply decorators (function composition)
  const loggedAdd = withLogging(add);
  const checkedLoggedAdd = withTypeCheck(loggedAdd);
  // Or compose directly: const composedAdd = withTypeCheck(withLogging(add));

  checkedLoggedAdd(5, 3);
  // Output:
  // Calling add with args: [ 5, 3 ]
  // Result: 8

  try {
    checkedLoggedAdd(5, "a");
  } catch (e) {
    console.error(e.message); // Output: All arguments must be numbers.
  }
  ```

**5. Proxy Pattern**

- **Concept:** Controls access to another object/function.
- **OOP Approach:** (As previously shown, using classes or native `Proxy`).
- **Functional Approach:** While JavaScript's native `Proxy` is object-oriented, you can achieve _some_ proxy-like behavior (like access control or logging) by wrapping functions, similar to decorators, but focused specifically on controlling access or interaction.

  ```javascript
  // Sensitive function
  const getSecretData = (userId) => {
    // Pretend to fetch data based on userId
    return `Secret data for user ${userId}`;
  };

  // Functional Proxy for access control
  const createAccessControlledGetter = (allowedUserId, fn) => {
    return (requestingUserId) => {
      if (requestingUserId === allowedUserId) {
        console.log(`Access granted for user ${requestingUserId}`);
        return fn(requestingUserId);
      } else {
        console.error(`Access denied for user ${requestingUserId}`);
        return null; // Or throw error
      }
    };
  };

  const getMySecretData = createAccessControlledGetter(
    "user123",
    getSecretData,
  );

  console.log(getMySecretData("user123"));
  // Output:
  // Access granted for user user123
  // Secret data for user user123

  console.log(getMySecretData("user456"));
  // Output:
  // Access denied for user user456
  // null
  ```

  _(Note: This is simpler than the native Proxy and lacks features like trapping property access on objects)._

**6. Facade Pattern**

- **Concept:** Provides a simplified interface to a complex subsystem.
- **OOP Approach:** (As previously shown, using a Facade class).
- **Functional Approach:** A single function orchestrates calls to several other functions, hiding the underlying complexity.

  ```javascript
  // "Subsystem" functions
  const setupAudio = () => {
    console.log("Audio ready.");
    return true;
  };
  const setupVideo = () => {
    console.log("Video ready.");
    return true;
  };
  const connectNetwork = (server) => {
    console.log(`Connected to ${server}.`);
    return "connectionId123";
  };
  const displayUI = (connId) =>
    console.log(`UI displayed for connection ${connId}.`);

  // Functional Facade
  const startConference = (server) => {
    console.log("--- Starting Conference ---");
    const audioOk = setupAudio();
    const videoOk = setupVideo();
    if (audioOk && videoOk) {
      const connectionId = connectNetwork(server);
      if (connectionId) {
        displayUI(connectionId);
        console.log("--- Conference Started Successfully ---");
        return true;
      }
    }
    console.error("--- Conference Start Failed ---");
    return false;
  };

  // Client uses the simple facade function
  startConference("conf.example.com");
  // Output:
  // --- Starting Conference ---
  // Audio ready.
  // Video ready.
  // Connected to conf.example.com.
  // UI displayed for connection connectionId123.
  // --- Conference Started Successfully ---
  ```

**7. Composite Pattern**

- **Concept:** Treats individual objects and compositions uniformly through a common interface.
- **OOP Approach:** (As previously shown, using base class/interface with Leaf and Composite classes).
- **Functional Approach:** Less direct mapping. Often involves defining functions that operate recursively on data structures (like trees or nested arrays) that represent the hierarchy. Functional programming favors processing data structures over mimicking object hierarchies.

  ```javascript
  // Represent hierarchy with nested data (e.g., objects or arrays)
  const fileSystem = {
    name: "root",
    type: "directory",
    children: [
      { name: "file1.txt", type: "file", size: 100 },
      {
        name: "subdir",
        type: "directory",
        children: [
          { name: "file2.txt", type: "file", size: 200 },
          { name: "notes.md", type: "file", size: 50 },
        ],
      },
      { name: "config.json", type: "file", size: 75 },
    ],
  };

  // Function to operate uniformly on the structure (e.g., calculate total size)
  const calculateTotalSize = (node) => {
    if (node.type === "file") {
      return node.size;
    }
    if (node.type === "directory") {
      // Recursively calculate size of children and sum them up
      return node.children.reduce(
        (total, child) => total + calculateTotalSize(child),
        0,
      );
    }
    return 0; // Should not happen with valid data
  };

  const totalSize = calculateTotalSize(fileSystem);
  console.log(`Total size: ${totalSize}`); // Output: Total size: 425

  // Another function: Find files by name (demonstrating uniform operation)
  const findFiles = (node, fileName) => {
    let found = [];
    if (node.type === "file" && node.name === fileName) {
      found.push(node);
    } else if (node.type === "directory") {
      node.children.forEach((child) => {
        found = found.concat(findFiles(child, fileName));
      });
    }
    return found;
  };
  console.log(findFiles(fileSystem, "file2.txt")); // Output: [ { name: 'file2.txt', type: 'file', size: 200 } ]
  ```

### Behavioral Patterns

**8. Observer Pattern**

- **Concept:** Notifies dependents (Observers) automatically when a subject's state changes.
- **OOP Approach:** (As previously shown, using Subject and Observer classes).
- **Functional Approach:** Often implemented using callbacks or event emitter patterns. A subject maintains a list of callback functions and invokes them when its state changes.

  ```javascript
  // Functional Subject (Event Emitter style)
  const createSubject = () => {
    let state = null;
    const observers = new Set(); // Use a Set to avoid duplicate callbacks

    const subscribe = (callback) => {
      observers.add(callback);
      console.log("Observer subscribed.");
      // Return an unsubscribe function
      return () => {
        observers.delete(callback);
        console.log("Observer unsubscribed.");
      };
    };

    const notify = (data) => {
      console.log("Notifying observers...");
      observers.forEach((callback) => {
        try {
          callback(data);
        } catch (err) {
          console.error("Error in observer callback:", err);
        }
      });
    };

    const setState = (newState) => {
      console.log(`State changing to: ${newState}`);
      state = newState;
      notify(state); // Notify observers about the new state
    };

    const getState = () => state;

    return { subscribe, setState, getState };
  };

  // Observer functions (callbacks)
  const observerCallback1 = (data) =>
    console.log(`Observer 1 received: ${data}`);
  const observerCallback2 = (data) =>
    console.log(`Observer 2 received: ${data.toUpperCase()}`);

  // Usage
  const subject = createSubject();

  const unsubscribe1 = subject.subscribe(observerCallback1);
  const unsubscribe2 = subject.subscribe(observerCallback2);

  subject.setState("Initial State");
  // Output:
  // Observer subscribed.
  // Observer subscribed.
  // State changing to: Initial State
  // Notifying observers...
  // Observer 1 received: Initial State
  // Observer 2 received: INITIAL STATE

  unsubscribe1(); // Unsubscribe observer 1

  subject.setState("Second State");
  // Output:
  // Observer unsubscribed.
  // State changing to: Second State
  // Notifying observers...
  // Observer 2 received: SECOND STATE
  ```

**9. Strategy Pattern**

- **Concept:** Defines a family of algorithms and makes them interchangeable.
- **OOP Approach:** (As previously shown, using Strategy classes).
- **Functional Approach:** Pass the algorithm (strategy) directly as a function argument.

  ```javascript
  // Context function that accepts a strategy function
  const calculatePrice = (basePrice, discountStrategy) => {
    const discount = discountStrategy(basePrice);
    console.log(`Applying discount: ${discount}`);
    return basePrice - discount;
  };

  // Strategy functions
  const noDiscount = (price) => 0;
  const tenPercentDiscount = (price) => price * 0.1;
  const fixedDiscount = (price) => (price > 50 ? 10 : 5); // $10 off if > $50, else $5

  // Using the strategies
  const itemPrice = 60;

  console.log(
    "Final Price (No Discount):",
    calculatePrice(itemPrice, noDiscount),
  );
  // Output: Applying discount: 0 -> Final Price: 60

  console.log(
    "Final Price (10% Off):",
    calculatePrice(itemPrice, tenPercentDiscount),
  );
  // Output: Applying discount: 6 -> Final Price: 54

  console.log(
    "Final Price (Fixed Discount):",
    calculatePrice(itemPrice, fixedDiscount),
  );
  // Output: Applying discount: 10 -> Final Price: 50

  console.log(
    "Final Price (Fixed Discount < 50):",
    calculatePrice(40, fixedDiscount),
  );
  // Output: Applying discount: 5 -> Final Price: 35
  ```

**10. Command Pattern**

- **Concept:** Encapsulates a request as an object (or function).
- **OOP Approach:** (As previously shown, using Command classes).
- **Functional Approach:** Represent commands simply as functions (often closures that capture necessary context).

  ```javascript
  // Receiver functions (representing the actions)
  const turnLightOn = (location) => console.log(`${location} light is ON`);
  const turnLightOff = (location) => console.log(`${location} light is OFF`);
  const setThermostat = (temp) => console.log(`Thermostat set to ${temp}C`);

  // Create command functions (closures capturing context)
  const createCommand = (action, ...args) => {
    return () => action(...args); // Return a zero-argument function that executes the action
  };

  // Create specific command functions
  const livingRoomLightOnCmd = createCommand(turnLightOn, "Living Room");
  const livingRoomLightOffCmd = createCommand(turnLightOff, "Living Room");
  const setHeatingCmd = createCommand(setThermostat, 22);

  // Invoker function (executes a command function)
  const executeCommand = (commandFn) => {
    console.log("Executing command...");
    commandFn();
  };

  // Execute commands
  executeCommand(livingRoomLightOnCmd); // Output: Executing command... -> Living Room light is ON
  executeCommand(setHeatingCmd); // Output: Executing command... -> Thermostat set to 22C
  executeCommand(livingRoomLightOffCmd); // Output: Executing command... -> Living Room light is OFF
  ```

**11. Iterator Pattern**

- **Concept:** Provides sequential access to elements without exposing underlying structure.
- **OOP Approach:** (As previously shown, often using classes with `next`, `hasNext`).
- **Functional Approach:** JavaScript's built-in iteration protocols (`Symbol.iterator`) and higher-order functions like `map`, `filter`, `reduce` on arrays are the idiomatic functional ways to process collections. Generators (`function*`) are also a powerful functional tool for creating custom iterators.

  ```javascript
  // Using built-in iteration on an Array
  const numbers = [1, 2, 3, 4, 5];
  console.log("Using map/filter:");
  const processedNumbers = numbers
    .filter((n) => n % 2 === 0) // Keep even numbers
    .map((n) => n * 10); // Multiply by 10
  console.log(processedNumbers); // Output: [ 20, 40 ]

  // Using a Generator function for custom iteration
  function* range(start, end, step = 1) {
    console.log("Generator started.");
    for (let i = start; i <= end; i += step) {
      yield i; // Pauses execution and yields a value
    }
    console.log("Generator finished.");
  }

  console.log("\nUsing generator:");
  const numberGenerator = range(1, 5, 2); // Create the generator iterator

  // Use with for...of
  for (const num of numberGenerator) {
    console.log(num);
  }
  // Output:
  // Generator started.
  // 1
  // 3
  // 5
  // Generator finished.

  // Or manually
  // console.log(numberGenerator.next()); // { value: 1, done: false }
  // console.log(numberGenerator.next()); // { value: 3, done: false }
  // ...
  ```

**12. Mediator Pattern**

- **Concept:** Centralizes communication between objects (Colleagues).
- **OOP Approach:** (As previously shown, using Mediator and Colleague classes).
- **Functional Approach:** Can be modeled using an event bus or pub/sub system (similar to the functional Observer). Colleagues publish events/messages, and the mediator/bus routes them to subscribed colleagues (callback functions). The core idea is decoupling direct function calls.

  ```javascript
  // Simple Pub/Sub implementation (functional Mediator)
  const createEventBus = () => {
    const subscriptions = {}; // topic -> Set of callbacks

    const subscribe = (topic, callback) => {
      if (!subscriptions[topic]) {
        subscriptions[topic] = new Set();
      }
      subscriptions[topic].add(callback);
      console.log(`Subscribed to topic: ${topic}`);
      // Return unsubscribe function
      return () => {
        if (subscriptions[topic]) {
          subscriptions[topic].delete(callback);
          console.log(`Unsubscribed from topic: ${topic}`);
        }
      };
    };

    const publish = (topic, data) => {
      if (subscriptions[topic]) {
        console.log(`Publishing to topic: ${topic}`, data);
        subscriptions[topic].forEach((callback) => {
          try {
            callback(data);
          } catch (e) {
            console.error(e);
          }
        });
      } else {
        console.log(`No subscribers for topic: ${topic}`);
      }
    };

    return { subscribe, publish };
  };

  // Colleagues (represented by functions interacting via the bus)
  const eventBus = createEventBus();

  const colleagueA = (data) => {
    console.log(`Colleague A received:`, data);
    if (data.value > 5) {
      eventBus.publish("colleagueA.processed", { result: data.value * 2 });
    }
  };

  const colleagueB = (data) => {
    console.log(`Colleague B received processed data:`, data);
  };

  // Subscriptions
  eventBus.subscribe("data.updated", colleagueA);
  const unsubB = eventBus.subscribe("colleagueA.processed", colleagueB);

  // Interaction
  eventBus.publish("data.updated", { value: 10, source: "sensor" });
  // Output:
  // Subscribed to topic: data.updated
  // Subscribed to topic: colleagueA.processed
  // Publishing to topic: data.updated { value: 10, source: 'sensor' }
  // Colleague A received: { value: 10, source: 'sensor' }
  // Publishing to topic: colleagueA.processed { result: 20 }
  // Colleague B received processed data: { result: 20 }

  unsubB(); // Colleague B unsubscribes

  eventBus.publish("data.updated", { value: 3, source: "manual" });
  // Output:
  // Unsubscribed from topic: colleagueA.processed
  // Publishing to topic: data.updated { value: 3, source: 'manual' }
  // Colleague A received: { value: 3, source: 'manual' }
  // No subscribers for topic: colleagueA.processed // B won't receive anything now
  ```

### JavaScript Specific Patterns

**13. Module Pattern / Revealing Module Pattern**

- **Concept:** Encapsulates private state/logic using closures.
- **OOP Approach:** N/A (This _is_ fundamentally a functional/closure-based pattern, though classes can achieve encapsulation differently).
- **Functional Approach:** (As previously shown, using IIFEs and closures is the standard way). This pattern is inherently functional in its JS implementation.
