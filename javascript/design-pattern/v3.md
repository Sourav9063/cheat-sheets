## Core Design Patterns in JavaScript (OOP & Functional Examples)

JavaScript's versatility allows developers to leverage various design patterns—both object-oriented and functional—to write modular, reusable, and maintainable code. Understanding these patterns is key to building robust applications. Below, we explore common patterns, showing both traditional OOP implementations and functional alternatives where applicable.

### Creational Patterns

_(Concerned with object creation mechanisms)_

**1. Singleton Pattern**

- **Concept:** Ensures a class has only one instance and provides a single, global point of access to it.
- **Use Case:** Managing shared resources like logging services, database connection pools, or application-wide configuration.

- **OOP Approach:**

  ```javascript
  class Logger {
    static _instance = null;

    static getInstance() {
      if (Logger._instance === null) {
        Logger._instance = new Logger();
        // Initialize instance properties if needed
        Logger._instance.logs = [];
      }
      return Logger._instance;
    }

    // Private constructor simulation (convention)
    constructor() {
      if (Logger._instance) {
        // Optional: prevent direct instantiation after singleton exists
        // throw new Error("Use Logger.getInstance() to get the single instance.");
      }
      // Initial setup can go here if needed ONCE
    }

    log(message) {
      const timestamp = new Date().toISOString();
      this.logs.push({ message, timestamp });
      console.log(`LOG [${timestamp}]: ${message}`);
    }

    getLogs() {
      return this.logs;
    }
  }

  const logger1 = Logger.getInstance();
  const logger2 = Logger.getInstance();

  console.log(logger1 === logger2); // true
  logger1.log("Singleton test message.");
  ```

---

- **Functional Approach:**

  - **Concept:** Achieved using closures and module patterns to create and hold a single instance within a private scope.
  - **Example:**

    ```javascript
    // Functional Singleton using a closure (Module Pattern)
    const createLoggerSingleton = () => {
      let instance; // Private instance store

      // Logger implementation details (can be an object literal)
      const loggerImplementation = {
        logs: [],
        log(message) {
          const timestamp = new Date().toISOString();
          this.logs.push({ message, timestamp });
          console.log(`LOG [${timestamp}]: ${message}`);
        },
        getLogs() {
          return this.logs;
        },
      };

      // The function to get the singleton instance
      return {
        getInstance: () => {
          if (!instance) {
            instance = loggerImplementation;
          }
          return instance;
        },
      };
    };

    const loggerSingleton = createLoggerSingleton();
    const loggerFunc1 = loggerSingleton.getInstance();
    const loggerFunc2 = loggerSingleton.getInstance();

    console.log(loggerFunc1 === loggerFunc2); // true
    loggerFunc1.log("Functional singleton message.");
    console.log(loggerFunc2.getLogs().length); // 1
    ```

**2. Factory Pattern**

- **Concept:** Provides an interface for creating objects but lets subclasses (or the factory itself) decide which class/object to instantiate/create. Decouples client from creation logic.
- **Use Case:** Creating different UI elements, user objects based on roles, or parsers based on file formats.

- **OOP Approach (Simple Factory):**

  ```javascript
  // Base class (optional, but good practice)
  class Animal {
    constructor(name) {
      this.name = name;
    }
    speak() {
      throw new Error("Subclass must implement speak method.");
    }
  }
  class Dog extends Animal {
    speak() {
      console.log(`${this.name} says Woof!`);
    }
  }
  class Cat extends Animal {
    speak() {
      console.log(`${this.name} says Meow!`);
    }
  }

  // The Factory function/class
  class AnimalFactory {
    createAnimal(type, name) {
      switch (type.toLowerCase()) {
        case "dog":
          return new Dog(name);
        case "cat":
          return new Cat(name);
        default:
          throw new Error("Invalid animal type specified");
      }
    }
  }

  const factory = new AnimalFactory();
  const dog = factory.createAnimal("dog", "Buddy");
  dog.speak(); // Output: Buddy says Woof!
  ```

---

- **Functional Approach:**

  - **Concept:** A higher-order function acts as the factory, returning different functions or configured objects.
  - **Example:**

    ```javascript
    // Functional Factory: Returns different *functions* based on type
    const createGreeter = (language) => {
      switch (language.toLowerCase()) {
        case "english":
          return (name) => `Hello, ${name}!`;
        case "spanish":
          return (name) => `Hola, ${name}!`;
        default:
          return (name) => `Hi there, ${name}!`;
      }
    };

    const greetInEnglish = createGreeter("english");
    console.log(greetInEnglish("Alice")); // Output: Hello, Alice!

    // Can also return configured objects
    const createApiConfig = (env) => {
      const base = { timeout: 5000 };
      return env === "production"
        ? { ...base, url: "https://api.prod.com", retries: 3 }
        : { ...base, url: "https://api.dev.com", retries: 1 };
    };
    const prodConfig = createApiConfig("production");
    console.log(prodConfig.url); // Output: https://api.prod.com
    ```

**3. Builder Pattern**

- **Concept:** Separates the construction of a complex object from its representation, allowing the same construction process to create different representations. Useful for objects with many optional parameters or configurations.
- **Use Case:** Building complex configuration objects, constructing database queries, creating complex UI components with many options.

- **OOP Approach:**

  ```javascript
  // The complex object we want to build
  class HttpClient {
    constructor(builder) {
      this.method = builder.method || "GET";
      this.url = builder.url;
      this.headers = builder.headers || {};
      this.body = builder.body || null;
      this.timeout = builder.timeout || 10000;
    }
    // Method to execute request (simplified)
    execute() {
      console.log(
        `Executing ${this.method} request to ${this.url} with timeout ${this.timeout}`,
      );
      // ... actual fetch logic ...
    }
  }

  // The Builder class
  class HttpClientBuilder {
    constructor(url) {
      // Required parameter
      this.url = url;
    }
    setMethod(method) {
      this.method = method;
      return this;
    } // Return this for chaining
    setHeaders(headers) {
      this.headers = headers;
      return this;
    }
    setBody(body) {
      this.body = body;
      return this;
    }
    setTimeout(timeout) {
      this.timeout = timeout;
      return this;
    }

    build() {
      // Creates the final object
      return new HttpClient(this);
    }
  }

  // Client uses the builder
  const client = new HttpClientBuilder("/api/users")
    .setMethod("POST")
    .setHeaders({
      "Content-Type": "application/json",
      Authorization: "Bearer xyz",
    })
    .setBody(JSON.stringify({ name: "Alice" }))
    .setTimeout(5000)
    .build();

  client.execute();
  // Output: Executing POST request to /api/users with timeout 5000
  ```

---

- **Functional Approach:**

  - **Concept:** Can be approximated using functions that progressively build up a configuration object, often leveraging function composition or currying. Less formal than the OOP Builder class structure.
  - **Example:**

    ```javascript
    // Base configuration function
    const createBaseConfig = (url) => ({
      url,
      method: "GET",
      headers: {},
      timeout: 10000,
    });

    // Functions to add/modify configuration properties (return new object)
    const withMethod = (method) => (config) => ({ ...config, method });
    const withHeaders = (headers) => (config) => ({
      ...config,
      headers: { ...config.headers, ...headers },
    });
    const withTimeout = (timeout) => (config) => ({ ...config, timeout });
    const withBody = (body) => (config) => ({ ...config, body });

    // Helper for function composition (pipe)
    const pipe =
      (...fns) =>
      (initialValue) =>
        fns.reduce((acc, fn) => fn(acc), initialValue);

    // Build configuration functionally
    const buildClientConfig = pipe(
      withMethod("POST"),
      withHeaders({ "Content-Type": "application/json" }),
      withHeaders({ Authorization: "Bearer xyz" }), // Headers merge
      withBody(JSON.stringify({ name: "Bob" })),
      withTimeout(3000),
    );

    const functionalConfig = buildClientConfig(createBaseConfig("/api/data"));

    console.log(functionalConfig);
    /* Output:
     {
       url: '/api/data',
       method: 'POST',
       headers: {
         'Content-Type': 'application/json',
         Authorization: 'Bearer xyz'
       },
       timeout: 3000,
       body: '{"name":"Bob"}'
     }
    */
    // A separate function would consume this config object to make the request
    ```

### Structural Patterns

_(Concerned with object composition and relationships)_

**4. Adapter Pattern**

- **Concept:** Allows objects with incompatible interfaces to work together by acting as a bridge or wrapper.
- **Use Case:** Integrating third-party libraries, legacy code, or different subsystems with incompatible APIs.

- **OOP Approach:**

  ```javascript
  // Existing interface expected by client
  class OldPaymentProcessor {
    process(amount) {
      console.log(`Processing $${amount} via Old System.`);
    }
  }
  // New service with a different interface
  class NewPaymentGateway {
    submitPayment(details) {
      console.log(
        `Submitting ${details.currency}${details.value} via New Gateway.`,
      );
    }
  }

  // Adapter
  class PaymentAdapter extends OldPaymentProcessor {
    constructor(newGateway) {
      super();
      this.gateway = newGateway;
    }
    process(amount) {
      // Adapt the old call to the new interface
      this.gateway.submitPayment({ value: amount, currency: "USD" });
    }
  }

  // Client code
  const processor = new PaymentAdapter(new NewPaymentGateway());
  processor.process(100); // Output: Submitting USD100 via New Gateway.
  ```

---

- **Functional Approach:**

  - **Concept:** A wrapper function adapts arguments or return values between incompatible function signatures.
  - **Example:**

    ```javascript
    // Client expects: (message: string) => void
    const displayNotification = (notifyFn) => notifyFn("Operation Successful!");

    // Service function signature: (options: { text: string, level: string }) => boolean
    const sendAlert = (options) => {
      console.log(`ALERT [${options.level}]: ${options.text}`);
      return true;
    };

    // Functional Adapter
    const alertAdapter = (message) => {
      // Adapt the simple message to the options object
      return sendAlert({ text: message, level: "info" });
    };

    displayNotification(alertAdapter);
    // Output: ALERT [info]: Operation Successful!
    ```

**5. Decorator Pattern**

- **Concept:** Attaches additional responsibilities or behaviors to an object or function dynamically.
- **Use Case:** Adding logging, timing, caching, or access control to functions/methods; enhancing UI components.

- **OOP Approach:**

  ```javascript
  // Component Interface
  class Coffee {
    cost() {
      return 5;
    }
    description() {
      return "Coffee";
    }
  }

  // Concrete Component
  class SimpleCoffee extends Coffee {}

  // Decorator Base Class
  class CoffeeDecorator extends Coffee {
    constructor(coffee) {
      super();
      this.decoratedCoffee = coffee;
    }
    cost() {
      return this.decoratedCoffee.cost();
    }
    description() {
      return this.decoratedCoffee.description();
    }
  }

  // Concrete Decorators
  class WithMilk extends CoffeeDecorator {
    cost() {
      return super.cost() + 1;
    }
    description() {
      return super.description() + ", Milk";
    }
  }
  class WithSugar extends CoffeeDecorator {
    cost() {
      return super.cost() + 0.5;
    }
    description() {
      return super.description() + ", Sugar";
    }
  }

  // Usage
  let myCoffee = new SimpleCoffee();
  console.log(`${myCoffee.description()} cost: $${myCoffee.cost()}`); // Coffee cost: $5
  myCoffee = new WithMilk(myCoffee);
  console.log(`${myCoffee.description()} cost: $${myCoffee.cost()}`); // Coffee, Milk cost: $6
  myCoffee = new WithSugar(myCoffee);
  console.log(`${myCoffee.description()} cost: $${myCoffee.cost()}`); // Coffee, Milk, Sugar cost: $6.5
  ```

---

- **Functional Approach:**

  - **Concept:** Higher-order functions naturally implement decorators by wrapping existing functions.
  - **Example:**

    ```javascript
    // Original function
    const fetchUser = (userId) => {
      console.log(`Workspaceing user ${userId}...`);
      return { id: userId, name: "Alice" };
    };

    // Decorator: Adds caching
    const withCache = (fn, cache = new Map()) => {
      return (...args) => {
        const key = JSON.stringify(args);
        if (cache.has(key)) {
          console.log(`Cache hit for key: ${key}`);
          return cache.get(key);
        } else {
          console.log(`Cache miss for key: ${key}`);
          const result = fn(...args);
          cache.set(key, result);
          return result;
        }
      };
    };

    // Decorator: Adds Logging
    const withSimpleLogging = (fn) => {
      return (...args) => {
        console.log(`Calling function ${fn.name}...`);
        return fn(...args);
      };
    };

    // Apply decorators
    const loggedFetchUser = withSimpleLogging(fetchUser);
    const cachedLoggedFetchUser = withCache(loggedFetchUser);

    cachedLoggedFetchUser(1); // Cache miss -> Calling function fetchUser... -> Fetching...
    cachedLoggedFetchUser(1); // Cache hit
    cachedLoggedFetchUser(2); // Cache miss -> Calling function fetchUser... -> Fetching...
    ```

**6. Proxy Pattern**

- **Concept:** Provides a surrogate or placeholder to control access to another object/function.
- **Use Case:** Implementing access control, caching, lazy loading, logging interactions.

- **OOP Approach (Native JS Proxy):**

  ```javascript
  const user = { name: "Bob", role: "user", sensitiveData: "abc" };

  const userProxy = new Proxy(user, {
    get(target, prop) {
      console.log(`Attempting to read property "${prop}"`);
      if (prop === "sensitiveData" && target.role !== "admin") {
        console.error(`Access denied to "${prop}" for role "${target.role}"`);
        return undefined;
      }
      return Reflect.get(target, prop);
    },
    set(target, prop, value) {
      console.log(`Attempting to set property "${prop}" to "${value}"`);
      if (prop === "role" && value !== "admin" && target.role === "admin") {
        console.warn("Cannot downgrade admin role.");
        return false; // Prevent setting
      }
      return Reflect.set(target, prop, value); // Allow setting
    },
  });

  console.log(userProxy.name); // Reads name
  console.log(userProxy.sensitiveData); // Denied
  userProxy.role = "guest"; // Allowed
  // userProxy.role = 'admin'; // This would work if allowed by logic
  ```

---

- **Functional Approach:**

  - **Concept:** Wrap functions to intercept calls, controlling access or adding behavior before delegation. Simpler than native Proxy, often focused on function calls rather than object properties.
  - **Example:**

    ```javascript
    // Function requiring admin privileges
    const performAdminAction = (action) =>
      console.log(`Performing admin action: ${action}`);

    // Functional Proxy for Role Check
    const createAdminProxy = (userRole, adminFn) => {
      return (...args) => {
        if (userRole === "admin") {
          console.log("Admin access verified.");
          return adminFn(...args);
        } else {
          console.error("Permission denied: Admin role required.");
          // return null or throw error
        }
      };
    };

    let currentUserRole = "user";
    const adminActionProxy = createAdminProxy(
      currentUserRole,
      performAdminAction,
    );

    adminActionProxy("delete logs"); // Error: Permission denied...

    // Simulate role change
    currentUserRole = "admin";
    const adminActionProxyNowAdmin = createAdminProxy(
      currentUserRole,
      performAdminAction,
    );
    adminActionProxyNowAdmin("delete logs");
    // Output:
    // Admin access verified.
    // Performing admin action: delete logs
    ```

**7. Facade Pattern**

- **Concept:** Provides a simplified, unified interface to a complex subsystem.
- **Use Case:** Simplifying interaction with complex libraries, frameworks, or sets of related services.

- **OOP Approach:**

  ```javascript
  // Complex subsystem parts
  class AuthSystem {
    authenticate(token) {
      console.log("Authenticated.");
      return { userId: "u1" };
    }
  }
  class ProfileSystem {
    getProfile(userId) {
      console.log("Fetched profile.");
      return { name: "Alice" };
    }
  }
  class SettingsSystem {
    getSettings(userId) {
      console.log("Fetched settings.");
      return { theme: "dark" };
    }
  }

  // Facade Class
  class UserSessionFacade {
    constructor() {
      this.auth = new AuthSystem();
      this.profile = new ProfileSystem();
      this.settings = new SettingsSystem();
    }

    getUserData(token) {
      console.log("--- Facade: Getting User Data ---");
      const authInfo = this.auth.authenticate(token);
      if (!authInfo) return null;
      const profileData = this.profile.getProfile(authInfo.userId);
      const settingsData = this.settings.getSettings(authInfo.userId);
      console.log("--- Facade: Done ---");
      return { ...authInfo, ...profileData, ...settingsData };
    }
  }

  // Client uses the facade
  const session = new UserSessionFacade();
  const userData = session.getUserData("validToken");
  console.log("User Data:", userData);
  ```

---

- **Functional Approach:**

  - **Concept:** A single function orchestrates calls to several other "subsystem" functions, hiding the complexity.
  - **Example:**

    ```javascript
    // "Subsystem" functions
    const authenticateUser = (token) => {
      console.log("Func: Authenticated.");
      return { userId: "u2" };
    };
    const fetchUserProfile = (userId) => {
      console.log("Func: Fetched profile.");
      return { name: "Bob" };
    };
    const fetchUserSettings = (userId) => {
      console.log("Func: Fetched settings.");
      return { theme: "light" };
    };

    // Functional Facade
    const getUserSessionData = (token) => {
      console.log("--- Func Facade: Getting User Data ---");
      const authInfo = authenticateUser(token);
      if (!authInfo) return null;
      // Could use Promise.all for async operations here
      const profileData = fetchUserProfile(authInfo.userId);
      const settingsData = fetchUserSettings(authInfo.userId);
      console.log("--- Func Facade: Done ---");
      return { ...authInfo, ...profileData, ...settingsData };
    };

    // Client uses the facade function
    const functionalUserData = getUserSessionData("anotherToken");
    console.log("Functional User Data:", functionalUserData);
    ```

**8. Composite Pattern**

- **Concept:** Composes objects into tree structures, allowing clients to treat individual objects (Leaves) and compositions (Nodes) uniformly.
- **Use Case:** Representing UI hierarchies, organizational structures, file systems.

- **OOP Approach:**

  ```javascript
  // Component Interface (abstract class or just convention)
  class FileSystemNode {
    constructor(name) {
      this.name = name;
    }
    getSize() {
      throw new Error("Subclass must implement getSize.");
    }
    // Other common methods like display(indent) could go here
  }

  // Leaf
  class File extends FileSystemNode {
    constructor(name, size) {
      super(name);
      this.size = size;
    }
    getSize() {
      return this.size;
    }
  }

  // Composite
  class Directory extends FileSystemNode {
    constructor(name) {
      super(name);
      this.children = [];
    }
    add(node) {
      this.children.push(node);
    }
    remove(node) {
      /* remove logic */
    }
    getSize() {
      // Calculate size by summing sizes of children
      return this.children.reduce((total, child) => total + child.getSize(), 0);
    }
  }

  // Usage
  const file1 = new File("a.txt", 10);
  const file2 = new File("b.doc", 25);
  const subDir = new Directory("sub");
  subDir.add(new File("c.js", 50));
  const rootDir = new Directory("root");
  rootDir.add(file1);
  rootDir.add(file2);
  rootDir.add(subDir);

  console.log(`Size of file1: ${file1.getSize()}`); // Output: 10
  console.log(`Size of subDir: ${subDir.getSize()}`); // Output: 50
  console.log(`Size of rootDir: ${rootDir.getSize()}`); // Output: 85 (10 + 25 + 50)
  ```

---

- **Functional Approach:**

  - **Concept:** Define functions that operate recursively on hierarchical data structures (like nested objects or arrays).
  - **Example:** (Using the same data structure as before)

    ```javascript
    const fileSystemData = {
      name: "root",
      type: "directory",
      children: [
        { name: "a.txt", type: "file", size: 10 },
        { name: "b.doc", type: "file", size: 25 },
        {
          name: "sub",
          type: "directory",
          children: [{ name: "c.js", type: "file", size: 50 }],
        },
      ],
    };

    // Function to calculate total size (same as before)
    const calculateTotalSize = (node) => {
      if (node.type === "file") return node.size;
      if (node.type === "directory") {
        return node.children.reduce(
          (total, child) => total + calculateTotalSize(child),
          0,
        );
      }
      return 0;
    };

    // Function to display structure
    const displayNode = (node, indent = 0) => {
      const prefix = " ".repeat(indent * 2);
      console.log(
        `${prefix}${node.type === "directory" ? "+" : "-"} ${node.name} ${
          node.type === "file" ? `(${node.size}b)` : ""
        }`,
      );
      if (node.type === "directory") {
        node.children.forEach((child) => displayNode(child, indent + 1));
      }
    };

    console.log(`Total size: ${calculateTotalSize(fileSystemData)}`); // Output: 85
    displayNode(fileSystemData);
    /* Output:
       + root
         - a.txt (10b)
         - b.doc (25b)
         + sub
           - c.js (50b)
    */
    ```

**9. Flyweight Pattern**

- **Concept:** Minimizes memory usage by sharing as much data as possible with other similar objects. It separates intrinsic (shared, immutable) state from extrinsic (unique, context-dependent) state.
- **Use Case:** Rendering huge numbers of similar objects (e.g., characters in a text editor, trees in a game), managing shared resources like network connections where the core connection can be reused.

- **OOP Approach:**

  ```javascript
  // Flyweight: Represents the shared (intrinsic) state
  class CharacterStyle {
    constructor(font, size, color) {
      this.font = font;
      this.size = size;
      this.color = color;
      console.log(`Creating Style: ${font}, ${size}pt, ${color}`); // Show when created
    }
    // Display method would use extrinsic state (position)
    display(char, x, y) {
      console.log(
        `Drawing '${char}' at (${x},${y}) with style [${this.font}, ${this.size}pt, ${this.color}]`,
      );
    }
  }

  // Flyweight Factory: Manages and shares flyweight instances
  class StyleFactory {
    constructor() {
      this.styles = {};
    }

    getStyle(font, size, color) {
      const key = `${font}-${size}-${color}`;
      if (!this.styles[key]) {
        this.styles[key] = new CharacterStyle(font, size, color);
      } else {
        console.log(`Reusing Style: ${font}, ${size}pt, ${color}`);
      }
      return this.styles[key];
    }

    getStylesCount() {
      return Object.keys(this.styles).length;
    }
  }

  // Client uses the factory
  const factory = new StyleFactory();

  const style1 = factory.getStyle("Arial", 12, "Black"); // Created
  const style2 = factory.getStyle("Times New Roman", 10, "Blue"); // Created
  const style3 = factory.getStyle("Arial", 12, "Black"); // Reused

  console.log(`Total styles created: ${factory.getStylesCount()}`); // Output: 2

  // Simulate drawing characters (extrinsic state: char, x, y)
  style1.display("H", 10, 20);
  style2.display("e", 20, 20);
  style3.display("l", 30, 20); // Uses reused style1 object
  style1.display("l", 40, 20);
  style2.display("o", 50, 20);
  ```

---

- **Functional Approach:**

  - **Concept:** More challenging to map directly. Focuses on memoization or caching functions that compute or retrieve shared data based on intrinsic state, while extrinsic state is passed as arguments.
  - **Example (using memoization for shared data retrieval):**

    ```javascript
    // Function to get potentially expensive shared data (e.g., icon data)
    const getIconData = (iconName) => {
      console.log(`Generating data for icon: ${iconName}`);
      // Simulate fetching/generating large data
      return `ICON_DATA_FOR_${iconName.toUpperCase()}`;
    };

    // Memoization function (simple version)
    const memoize = (fn) => {
      const cache = new Map();
      return (...args) => {
        const key = JSON.stringify(args);
        if (!cache.has(key)) {
          cache.set(key, fn(...args));
        } else {
          console.log(`Memoization hit for: ${key}`);
        }
        return cache.get(key);
      };
    };

    // Memoized function acts like the flyweight factory/cache
    const getMemoizedIconData = memoize(getIconData);

    // Client rendering function uses memoized getter for intrinsic state
    const renderIcon = (iconName, x, y) => {
      // Extrinsic state: x, y
      const iconData = getMemoizedIconData(iconName); // Gets shared data
      console.log(`Rendering icon at (${x},${y}) using data: ${iconData}`);
    };

    renderIcon("user", 10, 10); // Generates data
    renderIcon("settings", 20, 10); // Generates data
    renderIcon("user", 30, 10); // Memoization hit
    renderIcon("settings", 40, 10); // Memoization hit
    ```

### Behavioral Patterns

_(Concerned with object interaction and responsibility distribution)_

**10. Observer Pattern**

- **Concept:** Notifies dependents (Observers) automatically when a subject's state changes, promoting loose coupling.
- **Use Case:** Event handling (DOM), state management (Redux, Vuex), notification systems.

- **OOP Approach:**

  ```javascript
  class Subject {
    constructor() {
      this.observers = [];
    }
    attach(observer) {
      if (!this.observers.includes(observer)) this.observers.push(observer);
    }
    detach(observer) {
      this.observers = this.observers.filter((obs) => obs !== observer);
    }
    notify(data) {
      this.observers.forEach((obs) => obs.update(data));
    }
    // Method that causes state change
    updateData(newData) {
      console.log(`Subject: Data updated to "${newData}"`);
      this.notify(newData);
    }
  }
  // Observer Interface/Base
  class Observer {
    update(data) {
      throw new Error("Subclass must implement update.");
    }
  }
  // Concrete Observers
  class DataDisplay extends Observer {
    update(data) {
      console.log(`Display: Showing data - ${data}`);
    }
  }
  class DataLogger extends Observer {
    update(data) {
      console.log(`Logger: Logging data - ${data}`);
    }
  }

  // Usage
  const subject = new Subject();
  const display = new DataDisplay();
  const logger = new DataLogger();
  subject.attach(display);
  subject.attach(logger);
  subject.updateData("Hello");
  subject.detach(display);
  subject.updateData("World");
  ```

---

- **Functional Approach (Event Emitter / Pub/Sub):**

  - **Concept:** A subject maintains a list of callback functions and invokes them when state changes.
  - **Example:**

    ```javascript
    const createSubject = () => {
      const observers = new Set();
      const subscribe = (callback) => {
        observers.add(callback);
        return () => observers.delete(callback);
      };
      const notify = (data) => observers.forEach((cb) => cb(data));
      let state = null;
      const setState = (newState) => {
        state = newState;
        console.log(`State set to: ${state}`);
        notify(state);
      };
      const getState = () => state;
      return { subscribe, setState, getState };
    };

    // Observer callbacks
    const displayCallback = (data) => console.log(`Func Display: ${data}`);
    const loggerCallback = (data) => console.log(`Func Logger: ${data}`);

    const subjectFunc = createSubject();
    const unsubDisplay = subjectFunc.subscribe(displayCallback);
    const unsubLogger = subjectFunc.subscribe(loggerCallback);

    subjectFunc.setState("First Update");
    unsubDisplay(); // Unsubscribe display
    subjectFunc.setState("Second Update");
    ```

**11. Strategy Pattern**

- **Concept:** Defines a family of algorithms, encapsulates each, and makes them interchangeable at runtime.
- **Use Case:** Implementing different payment methods, sorting algorithms, validation rules, compression techniques.

- **OOP Approach:**

  ```javascript
  // Strategy Interface
  class ValidationStrategy {
    validate(value) {
      throw new Error("Implement!");
    }
  }
  // Concrete Strategies
  class NotEmpty extends ValidationStrategy {
    validate(value) {
      return value !== null && value !== undefined && value !== "";
    }
  }
  class IsEmail extends ValidationStrategy {
    validate(value) {
      return /\S+@\S+\.\S+/.test(value);
    }
  }
  class MinLength extends ValidationStrategy {
    constructor(min) {
      super();
      this.min = min;
    }
    validate(value) {
      return typeof value === "string" && value.length >= this.min;
    }
  }

  // Context
  class InputField {
    constructor(strategy) {
      this.strategy = strategy;
    }
    setStrategy(strategy) {
      this.strategy = strategy;
    }
    isValid(value) {
      return this.strategy.validate(value);
    }
  }

  // Usage
  const emailField = new InputField(new IsEmail());
  console.log(
    `'test@a.com' is valid email? ${emailField.isValid("test@a.com")}`,
  ); // true
  console.log(`'test' is valid email? ${emailField.isValid("test")}`); // false

  const nameField = new InputField(new MinLength(3));
  console.log(`'Al' is valid name (min 3)? ${nameField.isValid("Al")}`); // false
  console.log(`'Alice' is valid name (min 3)? ${nameField.isValid("Alice")}`); // true
  ```

---

- **Functional Approach:**

  - **Concept:** Pass the algorithm (strategy) directly as a function argument.
  - **Example:**

    ```javascript
    // Context function accepting a strategy function
    const validateInput = (value, validationFn) => {
      const result = validationFn(value);
      console.log(`Value "${value}" validation result: ${result}`);
      return result;
    };

    // Strategy functions
    const isNotEmpty = (val) => val !== null && val !== undefined && val !== "";
    const isValidEmail = (val) => /\S+@\S+\.\S+/.test(val);
    const createMinLengthValidator = (min) => (val) =>
      typeof val === "string" && val.length >= min;

    // Usage
    validateInput("hello@world.com", isValidEmail); // true
    validateInput("", isNotEmpty); // false
    validateInput("Bob", createMinLengthValidator(5)); // false
    validateInput("Charlie", createMinLengthValidator(5)); // true
    ```

**12. Command Pattern**

- **Concept:** Encapsulates a request as an object (or function), decoupling the invoker from the receiver and enabling queuing, logging, undo, etc.
- **Use Case:** Undo/redo functionality, task queuing, UI action handling, transaction management.

- **OOP Approach:**

  ```javascript
  // Receiver
  class Calculator {
    constructor() {
      this.value = 0;
    }
    add(x) {
      this.value += x;
    }
    subtract(x) {
      this.value -= x;
    }
  }
  // Command Interface
  class Command {
    execute() {}
    undo() {}
  }
  // Concrete Commands
  class AddCommand extends Command {
    constructor(calc, val) {
      super();
      this.calc = calc;
      this.val = val;
    }
    execute() {
      this.calc.add(this.val);
    }
    undo() {
      this.calc.subtract(this.val);
    }
  }
  class SubtractCommand extends Command {
    constructor(calc, val) {
      super();
      this.calc = calc;
      this.val = val;
    }
    execute() {
      this.calc.subtract(this.val);
    }
    undo() {
      this.calc.add(this.val);
    }
  }
  // Invoker (with history for undo)
  class CalcInvoker {
    constructor() {
      this.history = [];
      this.calculator = new Calculator();
    }
    executeCommand(cmd) {
      cmd.execute();
      this.history.push(cmd);
      this.log();
    }
    undoLast() {
      const cmd = this.history.pop();
      if (cmd) cmd.undo();
      this.log();
    }
    log() {
      console.log(`Current Value: ${this.calculator.value}`);
    }
  }

  // Usage
  const invoker = new CalcInvoker();
  invoker.executeCommand(new AddCommand(invoker.calculator, 10)); // Value: 10
  invoker.executeCommand(new AddCommand(invoker.calculator, 5)); // Value: 15
  invoker.undoLast(); // Value: 10
  invoker.undoLast(); // Value: 0
  ```

---

- **Functional Approach:**

  - **Concept:** Represent commands as functions, often closures capturing context. Undo can be handled by returning an "undo" function.
  - **Example:**

    ```javascript
    // Receiver state (simple object)
    let counter = { value: 0 };

    // Command function creator (returns execute and undo functions)
    const createCounterCommand = (action, val) => {
      let executed = false;
      return {
        execute: () => {
          if (action === "add") counter.value += val;
          if (action === "subtract") counter.value -= val;
          executed = true;
          console.log(`Executed ${action}(${val}). Current: ${counter.value}`);
        },
        undo: () => {
          if (!executed) return; // Can only undo if executed
          if (action === "add") counter.value -= val; // Reverse action
          if (action === "subtract") counter.value += val;
          console.log(`Undid ${action}(${val}). Current: ${counter.value}`);
          executed = false; // Mark as undone
        },
      };
    };

    // Invoker state and functions
    const commandHistory = [];
    const execute = (command) => {
      command.execute();
      commandHistory.push(command);
    };
    const undo = () => {
      const cmd = commandHistory.pop();
      if (cmd) cmd.undo();
    };

    // Usage
    execute(createCounterCommand("add", 5)); // Executed add(5). Current: 5
    execute(createCounterCommand("subtract", 2)); // Executed subtract(2). Current: 3
    undo(); // Undid subtract(2). Current: 5
    undo(); // Undid add(5). Current: 0
    ```

**13. Iterator Pattern**

- **Concept:** Provides sequential access to elements of a collection without exposing its underlying structure.
- **Use Case:** Iterating over custom data structures, providing different traversal methods, enabling `for...of` loops.

- **OOP Approach:**

  ```javascript
  class SimpleList {
    constructor() {
      this.items = [];
    }
    add(item) {
      this.items.push(item);
    }
    // Create an iterator object
    createIterator() {
      return new ListIterator(this);
    }
  }
  // Iterator class
  class ListIterator {
    constructor(list) {
      this.list = list;
      this.index = 0;
    }
    hasNext() {
      return this.index < this.list.items.length;
    }
    next() {
      return this.hasNext() ? this.list.items[this.index++] : undefined;
    }
  }

  // Usage
  const list = new SimpleList();
  list.add("A");
  list.add("B");
  list.add("C");
  const iterator = list.createIterator();
  while (iterator.hasNext()) {
    console.log(iterator.next());
  } // A, B, C
  ```

---

- **Functional Approach (Generators / Iterables):**

  - **Concept:** Use JavaScript's built-in iteration protocols (`Symbol.iterator`) and generators (`function*`) for custom iteration. Higher-order array methods (`map`, `filter`, `reduce`) are used for processing.
  - **Example:**

    ```javascript
    // Using built-in iterable protocol
    class WordCollection {
      constructor(str) {
        this.words = str.match(/\b(\w+)\b/g) || [];
      }
      // Make iterable
      [Symbol.iterator]() {
        let index = 0;
        const words = this.words;
        return {
          next: () => ({ value: words[index++], done: index > words.length }),
        };
      }
    }

    const sentence = new WordCollection("This is a test sentence.");
    for (const word of sentence) {
      console.log(word);
    } // This, is, a, test, sentence.

    // Using a Generator
    function* countDown(start) {
      console.log("Countdown started!");
      for (let i = start; i >= 0; i--) {
        yield i;
      }
      console.log("Countdown finished!");
    }
    for (const num of countDown(3)) {
      console.log(num);
    } // 3, 2, 1, 0
    ```

**14. Mediator Pattern**

- **Concept:** Centralizes communication between objects (Colleagues) via a Mediator object, promoting loose coupling.
- **Use Case:** Chat applications, coordinating UI elements, complex form logic, air traffic control.

- **OOP Approach:**

  ```javascript
  // Mediator Interface/Class
  class TrafficControlMediator {
    register(airplane) {}
    sendSignal(fromPlane, signal) {}
  }
  // Concrete Mediator
  class AirportControlTower extends TrafficControlMediator {
    constructor() {
      super();
      this.airplanes = new Set();
    }
    register(airplane) {
      this.airplanes.add(airplane);
      airplane.setMediator(this);
      console.log(`${airplane.name} registered.`);
    }
    sendSignal(fromPlane, signal) {
      console.log(
        `Tower received '${signal}' from ${fromPlane.name}. Relaying...`,
      );
      this.airplanes.forEach((plane) => {
        if (plane !== fromPlane) plane.receiveSignal(fromPlane.name, signal);
      });
    }
  }
  // Colleague Interface/Class
  class Airplane {
    constructor(name) {
      this.name = name;
      this.mediator = null;
    }
    setMediator(mediator) {
      this.mediator = mediator;
    }
    send(signal) {
      console.log(`${this.name} sending '${signal}'.`);
      this.mediator.sendSignal(this, signal);
    }
    receiveSignal(from, signal) {
      console.log(`${this.name} received '${signal}' from ${from}.`);
    }
  }

  // Usage
  const tower = new AirportControlTower();
  const plane1 = new Airplane("Flight 101");
  const plane2 = new Airplane("Flight 202");
  tower.register(plane1);
  tower.register(plane2);
  plane1.send("Requesting landing.");
  plane2.send("Holding pattern.");
  ```

---

- **Functional Approach (Pub/Sub or Event Bus):**

  - **Concept:** Use a central event bus where components (colleagues) publish messages/events identified by topics, and other components subscribe to topics to receive relevant messages.
  - **Example:** (Using the `createEventBus` function from the previous functional Mediator example)

    ```javascript
    const eventBus = createEventBus(); // Assume createEventBus exists

    // Colleague A (e.g., Input field)
    const inputField = (id) => {
      const publishChange = (value) => {
        console.log(`Input ${id} changed to: ${value}`);
        eventBus.publish("input.changed", { id, value });
      };
      return { publishChange };
    };

    // Colleague B (e.g., Submit button)
    const submitButton = (buttonId) => {
      let enabled = false;
      const onInputChange = (data) => {
        // Enable button only if input 'email' has value
        if (data.id === "email" && data.value) {
          if (!enabled) {
            console.log(`Button ${buttonId}: Enabling.`);
            enabled = true;
          }
        } else if (data.id === "email" && !data.value) {
          if (enabled) {
            console.log(`Button ${buttonId}: Disabling.`);
            enabled = false;
          }
        }
      };
      eventBus.subscribe("input.changed", onInputChange);
      console.log(`Button ${buttonId} initialized.`);
    };

    // Setup
    const emailInput = inputField("email");
    const mainSubmit = submitButton("mainSubmit");

    // Interaction
    emailInput.publishChange("test"); // Button enables
    emailInput.publishChange("test@example.com"); // Button remains enabled
    emailInput.publishChange(""); // Button disables
    ```

**15. State Pattern**

- **Concept:** Allows an object to alter its behavior when its internal state changes. The object appears to change its class. Encapsulates state-specific behavior into separate State objects.
- **Use Case:** Modeling states in games (e.g., Standing, Walking, Jumping), workflow processes (Draft, Review, Approved), managing connections (Connecting, Connected, Disconnected).

- **OOP Approach:**

  ```javascript
  // Context Class
  class TrafficLight {
    constructor() {
      this.state = new RedLightState(this); // Initial state
      console.log("Traffic Light initialized to RED.");
    }
    setState(newState) {
      console.log(
        `Changing state from ${this.state.constructor.name} to ${newState.constructor.name}`,
      );
      this.state = newState;
    }
    // Delegate actions to the current state
    requestChange() {
      this.state.handleChange();
    }
    getCurrentColor() {
      return this.state.color;
    }
  }

  // State Interface/Base Class
  class LightState {
    constructor(light) {
      this.light = light;
      this.color = "Unknown";
    }
    handleChange() {
      throw new Error("Subclass must implement handleChange.");
    }
  }

  // Concrete States
  class RedLightState extends LightState {
    constructor(light) {
      super(light);
      this.color = "Red";
    }
    handleChange() {
      this.light.setState(new GreenLightState(this.light));
    }
  }
  class YellowLightState extends LightState {
    constructor(light) {
      super(light);
      this.color = "Yellow";
    }
    handleChange() {
      this.light.setState(new RedLightState(this.light));
    }
  }
  class GreenLightState extends LightState {
    constructor(light) {
      super(light);
      this.color = "Green";
    }
    handleChange() {
      this.light.setState(new YellowLightState(this.light));
    }
  }

  // Usage
  const light = new TrafficLight();
  console.log(`Current color: ${light.getCurrentColor()}`); // Red
  light.requestChange(); // Changes to Green
  console.log(`Current color: ${light.getCurrentColor()}`); // Green
  light.requestChange(); // Changes to Yellow
  console.log(`Current color: ${light.getCurrentColor()}`); // Yellow
  light.requestChange(); // Changes to Red
  console.log(`Current color: ${light.getCurrentColor()}`); // Red
  ```

---

- **Functional Approach:**

  - **Concept:** Represent states as data (e.g., strings, objects) and use functions (like reducers in state management) to handle transitions and determine behavior based on the current state value. Less about encapsulating behavior _within_ state objects, more about functions _reacting_ to state values.
  - **Example (Simple State Machine):**

    ```javascript
    // Define states as constants
    const STATES = { RED: "RED", YELLOW: "YELLOW", GREEN: "GREEN" };

    // Transition function (determines next state)
    const transition = (currentState) => {
      switch (currentState) {
        case STATES.RED:
          return STATES.GREEN;
        case STATES.GREEN:
          return STATES.YELLOW;
        case STATES.YELLOW:
          return STATES.RED;
        default:
          return STATES.RED; // Default/initial
      }
    };

    // Function to get behavior based on state
    const getColor = (currentState) => currentState; // Simple example
    const canGo = (currentState) => currentState === STATES.GREEN;

    // Simulate the light
    let currentLightState = STATES.RED;
    console.log(
      `Initial State: ${getColor(currentLightState)}, Can Go? ${canGo(
        currentLightState,
      )}`,
    );

    currentLightState = transition(currentLightState);
    console.log(
      `Next State: ${getColor(currentLightState)}, Can Go? ${canGo(
        currentLightState,
      )}`,
    );

    currentLightState = transition(currentLightState);
    console.log(
      `Next State: ${getColor(currentLightState)}, Can Go? ${canGo(
        currentLightState,
      )}`,
    );

    currentLightState = transition(currentLightState);
    console.log(
      `Next State: ${getColor(currentLightState)}, Can Go? ${canGo(
        currentLightState,
      )}`,
    );
    ```

**16. Memento Pattern**

- **Concept:** Captures and externalizes an object's internal state (a "memento") so the object can be restored to this state later, without violating encapsulation.
- **Use Case:** Implementing undo/redo functionality, saving checkpoints in wizards or long processes.

- **OOP Approach:**

  ```javascript
  // Memento: Stores the state
  class EditorMemento {
    constructor(content) {
      this.content = content;
    }
    getContent() {
      return this.content;
    }
  }

  // Originator: Creates mementos and restores state from them
  class TextEditor {
    constructor() {
      this.content = "";
    }
    setContent(content) {
      this.content = content;
      console.log(`Content set: "${this.content}"`);
    }
    getContent() {
      return this.content;
    }
    // Creates a memento containing a snapshot of its current state
    save() {
      console.log("Saving state...");
      return new EditorMemento(this.content);
    }
    // Restores its state from a memento object
    restore(memento) {
      this.content = memento.getContent();
      console.log(`State restored to: "${this.content}"`);
    }
  }

  // Caretaker: Holds mementos, doesn't inspect them
  class History {
    constructor() {
      this.mementos = [];
    }
    addMemento(memento) {
      this.mementos.push(memento);
    }
    getMemento(index) {
      return this.mementos[index];
    }
    getLastMemento() {
      return this.mementos.pop();
    }
  }

  // Usage
  const editor = new TextEditor();
  const history = new History();

  editor.setContent("Version 1");
  history.addMemento(editor.save()); // Save V1

  editor.setContent("Version 2");
  history.addMemento(editor.save()); // Save V2

  editor.setContent("Version 3"); // Current state is V3

  // Undo (restore last saved state)
  const mementoV2 = history.getLastMemento();
  if (mementoV2) editor.restore(mementoV2); // Restores to V2

  // Undo again
  const mementoV1 = history.getLastMemento();
  if (mementoV1) editor.restore(mementoV1); // Restores to V1
  ```

---

- **Functional Approach:**

  - **Concept:** Focus on managing state immutably. Each "save" creates a new version of the state data. The history is simply a collection (e.g., an array) of these immutable state snapshots. Restoring means switching back to a previous state snapshot from the history.
  - **Example (Immutable State History):**

    ```javascript
    // Function to update state immutably
    const updateEditorState = (currentState, newContent) => {
      console.log(`Updating content to: "${newContent}"`);
      // Return a new state object instead of mutating
      return { ...currentState, content: newContent, timestamp: Date.now() };
    };

    // History management
    let history = [];
    let currentState = { content: "", timestamp: null }; // Initial state

    // Save current state to history
    const saveState = (stateToSave) => {
      console.log("Saving state...");
      history.push(stateToSave);
    };

    // Function to undo
    const undoState = () => {
      if (history.length > 1) {
        // Keep at least the initial state? Or allow empty?
        history.pop(); // Remove current from history (it wasn't 'saved' yet)
        const previousState = history[history.length - 1];
        console.log(
          `Restoring state from ${new Date(
            previousState.timestamp,
          ).toLocaleTimeString()}: "${previousState.content}"`,
        );
        return previousState;
      }
      console.log("Nothing to undo.");
      return history[0] || { content: "", timestamp: null }; // Return initial or last known state
    };

    // Usage
    saveState(currentState); // Save initial empty state

    currentState = updateEditorState(currentState, "Functional V1");
    saveState(currentState);

    currentState = updateEditorState(currentState, "Functional V2");
    saveState(currentState);

    currentState = updateEditorState(currentState, "Functional V3");
    // Don't save V3 yet

    console.log("Current:", currentState.content); // Functional V3

    // Undo
    currentState = undoState(); // Restores V2
    console.log("Current after undo:", currentState.content); // Functional V2

    // Undo again
    currentState = undoState(); // Restores V1
    console.log("Current after undo:", currentState.content); // Functional V1
    ```

**17. Chain of Responsibility Pattern**

- **Concept:** Passes a request along a chain of handlers. Each handler decides either to process the request or to pass it to the next handler in the chain. Decouples sender from receiver(s).
- **Use Case:** Processing pipelines (e.g., middleware in web frameworks), event bubbling in UIs, handling tiered approval processes, filtering requests.

- **OOP Approach:**

  ```javascript
  // Handler base class/interface
  class RequestHandler {
    constructor() {
      this.nextHandler = null;
    }
    setNext(handler) {
      this.nextHandler = handler;
      return handler;
    } // Allow chaining setup
    handle(request) {
      if (this.canHandle(request)) {
        this.process(request);
      } else if (this.nextHandler) {
        console.log(
          `${this.constructor.name} cannot handle, passing to next...`,
        );
        this.nextHandler.handle(request);
      } else {
        console.log("End of chain: Request unhandled.", request);
      }
    }
    // Methods to be implemented by subclasses
    canHandle(request) {
      throw new Error("Implement canHandle!");
    }
    process(request) {
      throw new Error("Implement process!");
    }
  }

  // Concrete Handlers
  class LoggerHandler extends RequestHandler {
    canHandle(request) {
      return true;
    } // Always logs
    process(request) {
      console.log(
        `LOG: Request received - ID ${request.id}, Type ${request.type}`,
      );
      /* Doesn't stop chain */ if (this.nextHandler)
        this.nextHandler.handle(request);
    }
  }
  class AuthHandler extends RequestHandler {
    canHandle(request) {
      return request.type === "secure";
    }
    process(request) {
      if (request.token === "valid") {
        console.log(`AUTH: Authorized request ${request.id}.`);
        if (this.nextHandler) this.nextHandler.handle(request);
      } else {
        console.error(
          `AUTH: Unauthorized request ${request.id}!`,
        ); /* Stop chain */
      }
    }
  }
  class DataHandler extends RequestHandler {
    canHandle(request) {
      return request.type === "data" || request.type === "secure";
    } // Handles both after auth
    process(request) {
      console.log(
        `DATA: Processing data for request ${request.id}. Payload: ${request.payload}`,
      ); /* End chain for this example */
    }
  }

  // Setup the chain: Logger -> Auth -> Data
  const logger = new LoggerHandler();
  const auth = new AuthHandler();
  const data = new DataHandler();
  logger.setNext(auth).setNext(data); // Chain them

  // Process requests
  console.log("--- Processing Secure Request (Valid) ---");
  logger.handle({
    id: 1,
    type: "secure",
    token: "valid",
    payload: "Secret Info",
  });
  console.log("\n--- Processing Secure Request (Invalid) ---");
  logger.handle({
    id: 2,
    type: "secure",
    token: "invalid",
    payload: "More Info",
  });
  console.log("\n--- Processing Data Request ---");
  logger.handle({ id: 3, type: "data", payload: "Public Info" });
  console.log("\n--- Processing Unknown Request ---");
  logger.handle({ id: 4, type: "unknown" });
  ```

---

- **Functional Approach:**

  - **Concept:** Represent the chain as an array or composition of functions. Each function takes the request and a `next` function as arguments. It either handles the request or calls `next(request)`. Middleware patterns in frameworks like Express.js are often functional examples.
  - **Example (Middleware Style):**

    ```javascript
    // Handler Functions (request, next) => void
    const loggerMiddleware = (req, next) => {
      console.log(`FUNC LOG: Request ID ${req.id}, Type ${req.type}`);
      next(req); // Always call next
    };

    const authMiddleware = (req, next) => {
      if (req.type === "secure") {
        if (req.token === "valid") {
          console.log(`FUNC AUTH: Authorized request ${req.id}.`);
          next(req); // Call next only if authorized
        } else {
          console.error(`FUNC AUTH: Unauthorized request ${req.id}!`);
          // Don't call next to stop the chain
        }
      } else {
        next(req); // Pass non-secure requests through
      }
    };

    const dataProcessorMiddleware = (req, next) => {
      if (req.type === "data" || req.type === "secure") {
        // Assumes secure requests were authed
        console.log(
          `FUNC DATA: Processing data for request ${req.id}. Payload: ${req.payload}`,
        );
        // This is the final handler in this example, so no 'next()' call
      } else {
        next(req); // Pass if not data/secure (though might be stopped by auth earlier)
      }
    };

    const unhandledMiddleware = (req, next) => {
      console.log("End of chain: Request unhandled.", req);
    };

    // Chain runner function
    const runChain = (request, middlewares) => {
      let index = -1;
      const dispatch = (i, currentRequest) => {
        if (i <= index)
          return Promise.reject(new Error("next() called multiple times")); // Prevent calling next multiple times synchronously
        index = i;
        const fn = middlewares[i];
        if (!fn) return Promise.resolve(); // End of chain

        try {
          // Call the middleware, passing the request and a function to call the *next* middleware
          return Promise.resolve(
            fn(currentRequest, (nextRequest = currentRequest) =>
              dispatch(i + 1, nextRequest),
            ),
          );
        } catch (err) {
          return Promise.reject(err);
        }
      };
      return dispatch(0, request).catch((err) =>
        console.error("Chain error:", err),
      );
    };

    // Define the chain
    const middlewareChain = [
      loggerMiddleware,
      authMiddleware,
      dataProcessorMiddleware,
      unhandledMiddleware,
    ];

    // Process requests
    console.log("--- Processing Secure Request (Valid) ---");
    runChain(
      { id: 1, type: "secure", token: "valid", payload: "Secret Info" },
      middlewareChain,
    );
    console.log("\n--- Processing Secure Request (Invalid) ---");
    runChain(
      { id: 2, type: "secure", token: "invalid", payload: "More Info" },
      middlewareChain,
    );
    console.log("\n--- Processing Data Request ---");
    runChain({ id: 3, type: "data", payload: "Public Info" }, middlewareChain);
    console.log("\n--- Processing Unknown Request ---");
    runChain({ id: 4, type: "unknown" }, middlewareChain);
    ```

### JavaScript Specific Patterns

**18. Module Pattern / Revealing Module Pattern**

- **Concept:** Uses closures (often IIFEs) to create private scopes, encapsulating implementation details and exposing only a public API. Essential before ES6 modules.
- **Use Case:** Creating reusable components/libraries with private state/methods, organizing code, avoiding global namespace pollution.
- **(This pattern is inherently functional/closure-based in JavaScript)**

- **OOP Approach:** N/A (Classes provide encapsulation differently).
- **Functional Approach:**

  ```javascript
  const createCounter = (initialValue = 0) => {
    let count = initialValue; // Private variable via closure

    // Private function (optional)
    const log = (message) =>
      console.log(`Counter [${initialValue}]: ${message}`);

    // Public API functions defined within the closure
    const increment = () => {
      count++;
      log(`Incremented to ${count}`);
    };
    const decrement = () => {
      count--;
      log(`Decremented to ${count}`);
    };
    const getValue = () => count;

    // Reveal the public API (Revealing Module Pattern)
    return {
      increment,
      decrement,
      value: getValue, // Can rename for public API
    };
  };

  // Each call creates a separate module instance with its own private state
  const counterA = createCounter();
  const counterB = createCounter(100);

  counterA.increment(); // Counter [0]: Incremented to 1
  counterB.decrement(); // Counter [100]: Decremented to 99
  console.log(counterA.value()); // 1
  console.log(counterB.value()); // 99
  // count, log are not accessible outside
  ```

### Additional Important Patterns

**19. Template Method Pattern**

- **Concept:** Defines the skeleton of an algorithm in a base class operation, deferring some steps to subclasses. Lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.
- **Use Case:** Creating frameworks where overall algorithm flow is fixed but specific implementations differ (e.g., data processing pipelines, report generation, build processes).

- **OOP Approach:**

  ```javascript
  // Abstract Base Class
  class DataProcessor {
    // The template method - defines the overall algorithm
    processData(source) {
      const data = this.loadData(source); // Step 1 (implemented by subclass)
      const processed = this.parseData(data); // Step 2 (implemented by subclass)
      this.hookBeforeSave(); // Step 3 (optional hook)
      this.saveData(processed); // Step 4 (implemented by subclass)
      console.log("Data processing complete.");
    }

    // Abstract methods (or default implementations) to be overridden
    loadData(source) {
      throw new Error("Subclass must implement loadData.");
    }
    parseData(data) {
      throw new Error("Subclass must implement parseData.");
    }
    saveData(data) {
      throw new Error("Subclass must implement saveData.");
    }

    // Hook method (optional, provides default behavior)
    hookBeforeSave() {
      console.log("Executing hook before saving...");
    }
  }

  // Concrete Subclass 1: CSV Processor
  class CsvProcessor extends DataProcessor {
    loadData(source) {
      console.log(`Loading CSV from ${source}`);
      return "csv_col1,csv_col2";
    }
    parseData(data) {
      console.log("Parsing CSV data");
      return data.split(",");
    }
    saveData(data) {
      console.log("Saving CSV data:", data);
    }
  }

  // Concrete Subclass 2: JSON Processor
  class JsonProcessor extends DataProcessor {
    loadData(source) {
      console.log(`Loading JSON from ${source}`);
      return '{"key": "value"}';
    }
    parseData(data) {
      console.log("Parsing JSON data");
      return JSON.parse(data);
    }
    saveData(data) {
      console.log("Saving JSON data:", data);
    }
    // Override the hook
    hookBeforeSave() {
      console.log("JSON Processor: Special pre-save action.");
    }
  }

  // Usage
  console.log("--- Processing CSV ---");
  const csvProcessor = new CsvProcessor();
  csvProcessor.processData("file.csv");

  console.log("\n--- Processing JSON ---");
  const jsonProcessor = new JsonProcessor();
  jsonProcessor.processData("data.json");
  ```

---

- **Functional Approach:**

  - **Concept:** Pass functions representing the variable steps of the algorithm as arguments to a higher-order function that defines the overall structure.
  - **Example:**

    ```javascript
    // Higher-order function defining the template/skeleton
    const createDataProcessor = (config) => {
      // Default implementations (can be overridden by config)
      const defaults = {
        hookBeforeSave: () => console.log("Executing hook before saving..."),
      };
      // Merge defaults with provided config
      const steps = { ...defaults, ...config };

      // Check for required steps
      if (!steps.loadData || !steps.parseData || !steps.saveData) {
        throw new Error("Missing required processing steps in config.");
      }

      // The processing function using configured steps
      return (source) => {
        const data = steps.loadData(source);
        const processed = steps.parseData(data);
        steps.hookBeforeSave();
        steps.saveData(processed);
        console.log("Functional Data processing complete.");
      };
    };

    // Define step functions for CSV processing
    const csvConfig = {
      loadData: (source) => {
        console.log(`Func Loading CSV from ${source}`);
        return "csv_col1,csv_col2";
      },
      parseData: (data) => {
        console.log("Func Parsing CSV data");
        return data.split(",");
      },
      saveData: (data) => {
        console.log("Func Saving CSV data:", data);
      },
    };

    // Define step functions for JSON processing
    const jsonConfig = {
      loadData: (source) => {
        console.log(`Func Loading JSON from ${source}`);
        return '{"key": "value"}';
      },
      parseData: (data) => {
        console.log("Func Parsing JSON data");
        return JSON.parse(data);
      },
      saveData: (data) => {
        console.log("Func Saving JSON data:", data);
      },
      hookBeforeSave: () => {
        console.log("Func JSON Processor: Special pre-save action.");
      }, // Override hook
    };

    // Create processor functions
    const processCsv = createDataProcessor(csvConfig);
    const processJson = createDataProcessor(jsonConfig);

    // Usage
    console.log("--- Func Processing CSV ---");
    processCsv("file.csv");

    console.log("\n--- Func Processing JSON ---");
    processJson("data.json");
    ```

**20. Abstract Factory Pattern**

- **Concept:** Provides an interface for creating families of related or dependent objects without specifying their concrete classes. Deals with creating _sets_ of related objects.
- **Use Case:** Creating UI components for different operating systems (Windows buttons/menus vs. Mac buttons/menus), swapping database implementations (SQL factory vs. NoSQL factory), managing different themes in an application.

- **OOP Approach:**

  ```javascript
  // Abstract Product Interfaces
  class Button {
    render() {}
  }
  class Checkbox {
    render() {}
  }

  // Concrete Products for Theme A
  class ButtonA extends Button {
    render() {
      console.log("Rendering Button - Theme A");
    }
  }
  class CheckboxA extends Checkbox {
    render() {
      console.log("Rendering Checkbox - Theme A");
    }
  }

  // Concrete Products for Theme B
  class ButtonB extends Button {
    render() {
      console.log("Rendering Button -- Theme B --");
    }
  }
  class CheckboxB extends Checkbox {
    render() {
      console.log("Rendering Checkbox -- Theme B --");
    }
  }

  // Abstract Factory Interface
  class UIFactory {
    createButton() {}
    createCheckbox() {}
  }

  // Concrete Factories
  class FactoryA extends UIFactory {
    createButton() {
      return new ButtonA();
    }
    createCheckbox() {
      return new CheckboxA();
    }
  }
  class FactoryB extends UIFactory {
    createButton() {
      return new ButtonB();
    }
    createCheckbox() {
      return new CheckboxB();
    }
  }

  // Client code uses a factory to create a family of related objects
  const createUI = (factory) => {
    const button = factory.createButton();
    const checkbox = factory.createCheckbox();
    button.render();
    checkbox.render();
  };

  console.log("--- Using Factory A (Theme A) ---");
  const factoryA = new FactoryA();
  createUI(factoryA);

  console.log("\n--- Using Factory B (Theme B) ---");
  const factoryB = new FactoryB();
  createUI(factoryB);
  ```

---

- **Functional Approach:**

  - **Concept:** Use configuration objects or higher-order functions that return sets of related functions or configured objects based on a theme/type parameter.
  - **Example:**

    ```javascript
    // Functions representing "products" for Theme A
    const renderButtonA = () => "Button (Theme A)";
    const renderCheckboxA = () => "Checkbox (Theme A)";

    // Functions representing "products" for Theme B
    const renderButtonB = () => "Button -- Theme B --";
    const renderCheckboxB = () => "Checkbox -- Theme B --";

    // Functional Factory: Returns an object containing related creation functions
    const getUIComponentCreators = (theme) => {
      switch (theme.toLowerCase()) {
        case "a":
          return {
            createButton: renderButtonA,
            createCheckbox: renderCheckboxA,
          };
        case "b":
          return {
            createButton: renderButtonB,
            createCheckbox: renderCheckboxB,
          };
        default:
          throw new Error(`Unknown theme: ${theme}`);
      }
    };

    // Client code uses the creators returned by the factory
    const buildFunctionalUI = (theme) => {
      const creators = getUIComponentCreators(theme);
      const button = creators.createButton();
      const checkbox = creators.createCheckbox();
      console.log(`Rendering: ${button}, ${checkbox}`);
    };

    console.log("--- Func Using Theme A ---");
    buildFunctionalUI("a"); // Output: Rendering: Button (Theme A), Checkbox (Theme A)

    console.log("\n--- Func Using Theme B ---");
    buildFunctionalUI("b"); // Output: Rendering: Button -- Theme B --, Checkbox -- Theme B --
    ```

**21. Bridge Pattern**

- **Concept:** Decouples an abstraction from its implementation so the two can vary independently. Uses composition over inheritance to connect the abstraction and implementation.
- **Use Case:** Supporting multiple platforms or APIs for a high-level abstraction (e.g., a generic `RemoteControl` working with different `Device` implementations like TV, Radio), separating UI components from underlying drawing APIs. Avoids combinatorial explosion of subclasses.

- **OOP Approach:**

  ```javascript
  // Implementation Interface (the "Implementor")
  class DrawingAPI {
    drawCircle(x, y, radius) {}
  }

  // Concrete Implementations
  class DrawingAPI1 extends DrawingAPI {
    drawCircle(x, y, radius) {
      console.log(`APIv1: Drawing circle at (${x},${y}) radius ${radius}`);
    }
  }
  class DrawingAPI2 extends DrawingAPI {
    drawCircle(x, y, radius) {
      console.log(`API_v2 -> draw_circle(${x}, ${y}, ${radius})`);
    }
  }

  // Abstraction Interface/Base Class
  class Shape {
    constructor(drawingAPI) {
      this.drawingAPI = drawingAPI; // Holds reference to the implementation
    }
    draw() {} // High-level operation
    resize(factor) {} // Another high-level op
  }

  // Refined Abstraction
  class CircleShape extends Shape {
    constructor(x, y, radius, drawingAPI) {
      super(drawingAPI);
      this.x = x;
      this.y = y;
      this.radius = radius;
    }
    draw() {
      // Delegates drawing to the implementation API
      this.drawingAPI.drawCircle(this.x, this.y, this.radius);
    }
    resize(factor) {
      this.radius *= factor;
    }
  }

  // Usage - Combine different abstractions with different implementations
  console.log("--- Circle with API v1 ---");
  const circle1 = new CircleShape(1, 2, 3, new DrawingAPI1());
  circle1.draw();

  console.log("\n--- Circle with API v2 ---");
  const circle2 = new CircleShape(5, 6, 7, new DrawingAPI2());
  circle2.draw();
  circle2.resize(2);
  circle2.draw(); // Radius is now 14
  ```

---

- **Functional Approach:**

  - **Concept:** Pass the implementation (specific functions) as arguments to the abstraction function. The abstraction function uses these passed-in functions to perform its work.
  - **Example:**

    ```javascript
    // Implementation functions (Implementors)
    const drawCircleAPI1 = (x, y, radius) =>
      `APIv1 Circle: (${x},${y}) r${radius}`;
    const drawCircleAPI2 = (x, y, radius) =>
      `API_v2 Circle -> (${x}, ${y}, ${radius})`;

    // Abstraction function: Takes implementation function and shape data
    const createCircleRenderer = (drawApi) => {
      return (circleData) => {
        // circleData holds state {x, y, radius}
        console.log("Func Drawing Circle...");
        // Call the passed-in drawing implementation
        const result = drawApi(circleData.x, circleData.y, circleData.radius);
        console.log(result);
        return result; // Return result if needed
      };
    };

    // Function to modify shape data (returns new state)
    const resizeCircle = (circleData, factor) => {
      return { ...circleData, radius: circleData.radius * factor };
    };

    // Usage: Combine abstraction with different implementations
    let circleState = { x: 10, y: 20, radius: 5 };

    console.log("--- Func Circle with API v1 ---");
    const renderWithAPI1 = createCircleRenderer(drawCircleAPI1);
    renderWithAPI1(circleState); // Output: APIv1 Circle: (10,20) r5

    console.log("\n--- Func Circle with API v2 ---");
    const renderWithAPI2 = createCircleRenderer(drawCircleAPI2);
    circleState = resizeCircle(circleState, 3); // Update state immutably
    renderWithAPI2(circleState); // Output: API_v2 Circle -> (10, 20, 15)
    ```

**22. Prototype Pattern**

- **Concept:** Specifies the kinds of objects to create using a prototypical instance, and creates new objects by copying (cloning) this prototype.
- **Use Case:** When object creation is expensive (e.g., involves database calls, complex setup), or when you want to create variations of an object easily without going through a complex constructor or factory process. JavaScript's prototypal inheritance is related but this pattern focuses on explicit cloning.

- **OOP Approach:**

  ```javascript
  // Prototype Interface/Base Class (with a clone method)
  class ShapePrototype {
    constructor(color) {
      this.color = color;
    }
    clone() {
      throw new Error("Subclass must implement clone.");
    }
    display() {}
  }

  // Concrete Prototypes
  class Rectangle extends ShapePrototype {
    constructor(width, height, color) {
      super(color);
      this.width = width;
      this.height = height;
      console.log(
        `Creating Rectangle prototype (${width}x${height}, ${color})`,
      );
    }
    clone() {
      // Create a new object by copying properties
      // For complex objects, might need deep cloning
      console.log(
        `Cloning Rectangle (${this.width}x${this.height}, ${this.color})`,
      );
      return Object.assign(Object.create(Object.getPrototypeOf(this)), this);
      // Or using structuredClone for deep copy in modern JS:
      // return structuredClone(this);
    }
    display() {
      console.log(
        `Rectangle: ${this.width}x${this.height}, Color: ${this.color}`,
      );
    }
  }

  // Client uses prototypes to create new objects
  const redRectPrototype = new Rectangle(10, 5, "Red"); // Create initial prototype

  // Clone the prototype to create new instances
  const rect1 = redRectPrototype.clone();
  rect1.width = 12; // Modify the clone

  const rect2 = redRectPrototype.clone();
  rect2.color = "Blue"; // Modify the clone

  redRectPrototype.display(); // Original prototype
  rect1.display(); // Modified clone 1
  rect2.display(); // Modified clone 2
  ```

---

- **Functional Approach:**

  - **Concept:** Focus on creating new state objects based on existing ones, typically using object spread syntax (`...`) or functions that merge properties onto a base template object. Explicit `clone` methods are less common.
  - **Example:**

    ```javascript
    // Define a "prototype" or template object
    const baseButtonConfig = {
      text: "Click Me",
      padding: 10,
      color: "blue",
      onClick: () => console.log("Button clicked!"),
    };

    // Function to create variations by merging with the base
    const createButtonVariant = (overrides) => {
      console.log("Creating button variant with overrides:", overrides);
      // Use spread syntax to "clone" and override
      return { ...baseButtonConfig, ...overrides };
    };

    // Create new button configurations based on the prototype/template
    const submitButtonConfig = createButtonVariant({
      text: "Submit",
      color: "green",
      onClick: () => console.log("Submitting form..."),
    });

    const cancelButtonConfig = createButtonVariant({
      text: "Cancel",
      color: "red",
      onClick: () => console.log("Cancelling..."),
    });

    // Simulate rendering/using the configs
    console.log("Submit Button:", submitButtonConfig);
    submitButtonConfig.onClick();

    console.log("Cancel Button:", cancelButtonConfig);
    cancelButtonConfig.onClick();

    console.log("Base Button:", baseButtonConfig); // Base remains unchanged
    ```

**23. Visitor Pattern**

- **Concept:** Represents an operation to be performed on the elements of an object structure (like a Composite). Visitor lets you define a new operation without changing the classes of the elements on which it operates. Achieves separation of concerns: structure vs. operations on structure.
- **Use Case:** Performing distinct and unrelated operations on a complex object structure (e.g., Abstract Syntax Tree, document object model) without cluttering the element classes. Examples: type checking, code generation, pretty printing on an AST.

- **OOP Approach:**

  ```javascript
  // Element Interface (objects that can be visited)
  class DocumentPart {
    accept(visitor) {}
  }

  // Concrete Elements
  class Paragraph extends DocumentPart {
    constructor(text) {
      super();
      this.text = text;
    }
    accept(visitor) {
      visitor.visitParagraph(this);
    } // Double dispatch
  }
  class Heading extends DocumentPart {
    constructor(text, level) {
      super();
      this.text = text;
      this.level = level;
    }
    accept(visitor) {
      visitor.visitHeading(this);
    } // Double dispatch
  }
  class Document extends DocumentPart {
    constructor(parts) {
      super();
      this.parts = parts;
    }
    accept(visitor) {
      visitor.visitDocumentStart(this);
      this.parts.forEach((part) => part.accept(visitor)); // Visit children
      visitor.visitDocumentEnd(this);
    }
  }

  // Visitor Interface
  class Visitor {
    visitParagraph(paragraph) {}
    visitHeading(heading) {}
    visitDocumentStart(doc) {}
    visitDocumentEnd(doc) {}
  }

  // Concrete Visitor 1: HTML Exporter
  class HtmlExporter extends Visitor {
    constructor() {
      super();
      this.output = "";
    }
    visitDocumentStart(doc) {
      this.output += "<html><body>\n";
    }
    visitParagraph(p) {
      this.output += `  <p>${p.text}</p>\n`;
    }
    visitHeading(h) {
      this.output += `  <h${h.level}>${h.text}</h${h.level}>\n`;
    }
    visitDocumentEnd(doc) {
      this.output += "</body></html>";
    }
    getHtml() {
      return this.output;
    }
  }

  // Concrete Visitor 2: Word Counter
  class WordCounter extends Visitor {
    constructor() {
      super();
      this.count = 0;
    }
    countWords(text) {
      return (text.match(/\b\w+\b/g) || []).length;
    }
    visitParagraph(p) {
      this.count += this.countWords(p.text);
    }
    visitHeading(h) {
      this.count += this.countWords(h.text);
    }
    getCount() {
      return this.count;
    }
  }

  // Usage
  const doc = new Document([
    new Heading("Chapter 1", 1),
    new Paragraph("This is the first paragraph."),
    new Heading("Section 1.1", 2),
    new Paragraph("Another paragraph here."),
  ]);

  // Use HTML Exporter Visitor
  const htmlExporter = new HtmlExporter();
  doc.accept(htmlExporter);
  console.log("--- HTML Output ---");
  console.log(htmlExporter.getHtml());

  // Use Word Counter Visitor
  const wordCounter = new WordCounter();
  doc.accept(wordCounter);
  console.log("\n--- Word Count ---");
  console.log(`Total words: ${wordCounter.getCount()}`); // Output: 14
  ```

---

- **Functional Approach:**

  - **Concept:** Less direct mapping. Often involves using functions like `map`, `filter`, `reduce` combined with pattern matching (e.g., `switch` statements or object lookups based on node `type`) to recursively traverse and process data structures. The "visitor" logic is contained within these traversal functions rather than separate visitor objects.
  - **Example (Processing a similar document structure):**

    ```javascript
    // Represent document structure as data
    const documentData = {
      type: "document",
      parts: [
        { type: "heading", level: 1, text: "Chapter 1 Func" },
        { type: "paragraph", text: "First functional paragraph." },
        { type: "heading", level: 2, text: "Section 1.1 Func" },
        { type: "paragraph", text: "More functional text here." },
      ],
    };

    // "Visitor" Logic 1: Generate Markdown
    const generateMarkdown = (node) => {
      switch (node.type) {
        case "document":
          // Recursively process parts and join results
          return node.parts.map(generateMarkdown).join("\n");
        case "heading":
          return `${"#".repeat(node.level)} ${node.text}`;
        case "paragraph":
          return node.text;
        default:
          return "";
      }
    };

    // "Visitor" Logic 2: Count words
    const countWords = (text) => (text.match(/\b\w+\b/g) || []).length;
    const countTotalWords = (node) => {
      switch (node.type) {
        case "document":
          // Recursively process parts and sum results
          return node.parts.reduce(
            (sum, part) => sum + countTotalWords(part),
            0,
          );
        case "heading": // Fallthrough
        case "paragraph":
          return countWords(node.text);
        default:
          return 0;
      }
    };

    // Usage
    console.log("--- Functional Markdown Output ---");
    console.log(generateMarkdown(documentData));

    console.log("\n--- Functional Word Count ---");
    console.log(`Total words: ${countTotalWords(documentData)}`); // Output: 15
    ```

### Lesser-Known / Specific Patterns

**24. Dependency Injection (DI) / Inversion of Control (IoC)**

- **Concept:** IoC is a principle where the control over object creation and dependency linking is inverted; instead of an object creating its dependencies, the dependencies are provided (injected) from an external source (like a container or manual wiring). DI is a common technique to achieve IoC. This promotes loose coupling and improves testability.
- **Use Case:** Managing dependencies in complex applications, especially within frameworks (Angular, NestJS), facilitating unit testing by allowing mock dependencies to be injected, making components more reusable and configurable.

- **OOP Approach (Constructor Injection):**

  ```javascript
  // Dependency (e.g., a service)
  class NotificationService {
    send(message) {
      console.log(`OOP Notifier: Sending notification - ${message}`);
    }
  }

  // Dependent Class (requires the dependency)
  class OrderProcessor {
    // Dependency is injected via the constructor
    constructor(notifier) {
      if (!notifier)
        throw new Error("NotificationService dependency is required.");
      this.notificationService = notifier;
    }

    processOrder(orderId) {
      console.log(`Processing order ${orderId}...`);
      // Uses the injected dependency
      this.notificationService.send(`Order ${orderId} processed successfully.`);
      console.log(`Order ${orderId} finished.`);
    }
  }

  // Wiring dependencies (could be done manually or by a DI container)
  const notifier = new NotificationService();
  const orderProcessor = new OrderProcessor(notifier);

  orderProcessor.processOrder("A123");

  // For testing, inject a mock:
  class MockNotifier {
    send(message) {
      console.log(`MOCK Notifier: Would send - ${message}`);
    }
  }
  const mockProcessor = new OrderProcessor(new MockNotifier());
  mockProcessor.processOrder("B456");
  ```

---

- **Functional Approach:**

  - **Concept:** Pass dependencies explicitly as arguments to functions, often using higher-order functions or currying to "inject" them.
  - **Example (Function Argument Injection):**

    ```javascript
    // Dependency function
    const sendNotificationFunc = (message) => {
      console.log(`FUNC Notifier: Sending notification - ${message}`);
    };

    // Dependent function (takes dependency as an argument)
    const processOrderFunc = (notifierFunc, orderId) => {
      console.log(`Func Processing order ${orderId}...`);
      // Uses the passed-in dependency function
      notifierFunc(`Order ${orderId} processed successfully.`);
      console.log(`Func Order ${orderId} finished.`);
    };

    // "Injecting" by passing the function
    processOrderFunc(sendNotificationFunc, "C789");

    // For testing, pass a mock function:
    const mockNotifierFunc = (message) =>
      console.log(`FUNC MOCK Notifier: Would send - ${message}`);
    processOrderFunc(mockNotifierFunc, "D012");

    // Alternative: Using a higher-order function for configuration
    const createOrderProcessorWithNotifier = (notifierFunc) => {
      // Returns a function with the dependency "baked in" via closure
      return (orderId) => {
        console.log(`Func (configured) Processing order ${orderId}...`);
        notifierFunc(`Order ${orderId} processed successfully.`);
        console.log(`Func (configured) Order ${orderId} finished.`);
      };
    };

    const configuredProcessor =
      createOrderProcessorWithNotifier(sendNotificationFunc);
    configuredProcessor("E345");
    ```

**25. Null Object Pattern**

- **Concept:** Provides a default object that acts as a safe, do-nothing placeholder for an expected object when `null` or `undefined` might otherwise occur. This avoids conditional checks for null/undefined before calling methods.
- **Use Case:** Simplifying client code by providing a non-null default object (e.g., a default "Guest" user, a "No Operation" logger, a default strategy), preventing null reference errors.

- **OOP Approach:**

  ```javascript
  // Interface / Base Class for the expected object
  class AbstractUser {
    constructor(name) {
      this.name = name;
    }
    hasAccess(resource) {
      return false;
    } // Default deny
    getName() {
      return this.name;
    }
  }

  // Real Object
  class RealUser extends AbstractUser {
    constructor(name, permissions) {
      super(name);
      this.permissions = permissions || [];
    }
    hasAccess(resource) {
      return this.permissions.includes(resource);
    }
  }

  // Null Object (implements the same interface, provides safe defaults)
  class GuestUser extends AbstractUser {
    constructor() {
      super("Guest");
    }
    // Overrides provide safe, do-nothing, or default behavior
    hasAccess(resource) {
      return false;
    } // Guests have no access
    getName() {
      return "Guest";
    }
  }

  // Client code that might receive a real user or a null object
  const getUser = (userId) => {
    if (userId === 1) return new RealUser("Alice", ["dashboard", "profile"]);
    // Instead of returning null, return the Null Object
    return new GuestUser();
  };

  const user1 = getUser(1);
  const user2 = getUser(99); // Gets GuestUser

  // Client code doesn't need null checks
  console.log(
    `User 1: ${user1.getName()}, Access Dashboard? ${user1.hasAccess(
      "dashboard",
    )}`,
  );
  console.log(
    `User 2: ${user2.getName()}, Access Dashboard? ${user2.hasAccess(
      "dashboard",
    )}`,
  );
  ```

---

- **Functional Approach:**

  - **Concept:** Define default functions or configuration objects that provide safe, no-op, or default behavior, and return these defaults instead of `null` or `undefined`.
  - **Example:**

    ```javascript
    // Functions representing user actions
    const canAccessResource = (user, resource) => {
      // Check if user and permissions exist before checking includes
      return user && user.permissions && user.permissions.includes(resource);
    };
    const getUserDisplayName = (user) => {
      return user ? user.name : "Guest"; // Default name if user is null/undefined
    };

    // "Null Object" equivalent - a default user object structure
    const guestUserObject = {
      name: "Guest",
      permissions: [], // Empty permissions provide safe default for checks
    };

    // Client code getting user data (might return null/undefined or the guest object)
    const findUserFunc = (userId) => {
      if (userId === 1) return { name: "Bob", permissions: ["profile"] };
      // Instead of returning null/undefined, return the default object
      return guestUserObject;
    };

    const userFunc1 = findUserFunc(1);
    const userFunc2 = findUserFunc(100); // Gets guestUserObject

    // Client code uses functions that handle potential "nullness" or defaults
    console.log(
      `User Func 1: ${getUserDisplayName(
        userFunc1,
      )}, Access Profile? ${canAccessResource(userFunc1, "profile")}`,
    );
    console.log(
      `User Func 2: ${getUserDisplayName(
        userFunc2,
      )}, Access Profile? ${canAccessResource(userFunc2, "profile")}`,
    );

    // Alternative: Return default *functions*
    const getGreeter = (userName) => {
      if (userName) {
        return () => console.log(`Hello, ${userName}!`);
      } else {
        // Return a "null" function that does nothing safely
        return () => console.log("Hello, Guest!"); // Or just () => {}
      }
    };

    const greetAlice = getGreeter("Alice");
    const greetGuest = getGreeter(null);

    greetAlice();
    greetGuest();
    ```
